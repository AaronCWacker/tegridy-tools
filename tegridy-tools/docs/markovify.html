<!doctype html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />

  
  <title>markovify API documentation</title>
  <meta name="description" content="markovify.py" />


  <link href='https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,300' rel='stylesheet' type='text/css'>
  
  <style type="text/css">
* {
  box-sizing: border-box;
}
/*! normalize.css v1.1.1 | MIT License | git.io/normalize */

/* ==========================================================================
   HTML5 display definitions
   ========================================================================== */

/**
 * Correct `block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

article,
aside,
details,
figcaption,
figure,
footer,
header,
hgroup,
main,
nav,
section,
summary {
    display: block;
}

/**
 * Correct `inline-block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

audio,
canvas,
video {
    display: inline-block;
    *display: inline;
    *zoom: 1;
}

/**
 * Prevent modern browsers from displaying `audio` without controls.
 * Remove excess height in iOS 5 devices.
 */

audio:not([controls]) {
    display: none;
    height: 0;
}

/**
 * Address styling not present in IE 7/8/9, Firefox 3, and Safari 4.
 * Known issue: no IE 6 support.
 */

[hidden] {
    display: none;
}

/* ==========================================================================
   Base
   ========================================================================== */

/**
 * 1. Prevent system color scheme's background color being used in Firefox, IE,
 *    and Opera.
 * 2. Prevent system color scheme's text color being used in Firefox, IE, and
 *    Opera.
 * 3. Correct text resizing oddly in IE 6/7 when body `font-size` is set using
 *    `em` units.
 * 4. Prevent iOS text size adjust after orientation change, without disabling
 *    user zoom.
 */

html {
    background: #fff; /* 1 */
    color: #000; /* 2 */
    font-size: 100%; /* 3 */
    -webkit-text-size-adjust: 100%; /* 4 */
    -ms-text-size-adjust: 100%; /* 4 */
}

/**
 * Address `font-family` inconsistency between `textarea` and other form
 * elements.
 */

html,
button,
input,
select,
textarea {
    font-family: sans-serif;
}

/**
 * Address margins handled incorrectly in IE 6/7.
 */

body {
    margin: 0;
}

/* ==========================================================================
   Links
   ========================================================================== */

/**
 * Address `outline` inconsistency between Chrome and other browsers.
 */

a:focus {
    outline: thin dotted;
}

/**
 * Improve readability when focused and also mouse hovered in all browsers.
 */

a:active,
a:hover {
    outline: 0;
}

/* ==========================================================================
   Typography
   ========================================================================== */

/**
 * Address font sizes and margins set differently in IE 6/7.
 * Address font sizes within `section` and `article` in Firefox 4+, Safari 5,
 * and Chrome.
 */

h1 {
    font-size: 2em;
    margin: 0.67em 0;
}

h2 {
    font-size: 1.5em;
    margin: 0.83em 0;
}

h3 {
    font-size: 1.17em;
    margin: 1em 0;
}

h4 {
    font-size: 1em;
    margin: 1.33em 0;
}

h5 {
    font-size: 0.83em;
    margin: 1.67em 0;
}

h6 {
    font-size: 0.67em;
    margin: 2.33em 0;
}

/**
 * Address styling not present in IE 7/8/9, Safari 5, and Chrome.
 */

abbr[title] {
    border-bottom: 1px dotted;
}

/**
 * Address style set to `bolder` in Firefox 3+, Safari 4/5, and Chrome.
 */

b,
strong {
    font-weight: bold;
}

blockquote {
    margin: 1em 40px;
}

/**
 * Address styling not present in Safari 5 and Chrome.
 */

dfn {
    font-style: italic;
}

/**
 * Address differences between Firefox and other browsers.
 * Known issue: no IE 6/7 normalization.
 */

hr {
    -moz-box-sizing: content-box;
    box-sizing: content-box;
    height: 0;
}

/**
 * Address styling not present in IE 6/7/8/9.
 */

mark {
    background: #ff0;
    color: #000;
}

/**
 * Address margins set differently in IE 6/7.
 */

p,
pre {
    margin: 1em 0;
}

/**
 * Correct font family set oddly in IE 6, Safari 4/5, and Chrome.
 */

code,
kbd,
pre,
samp {
    font-family: monospace, serif;
    _font-family: 'courier new', monospace;
    font-size: 1em;
}

/**
 * Improve readability of pre-formatted text in all browsers.
 */

pre {
    white-space: pre;
    white-space: pre-wrap;
    word-wrap: break-word;
}

/**
 * Address CSS quotes not supported in IE 6/7.
 */

q {
    quotes: none;
}

/**
 * Address `quotes` property not supported in Safari 4.
 */

q:before,
q:after {
    content: '';
    content: none;
}

/**
 * Address inconsistent and variable font size in all browsers.
 */

small {
    font-size: 80%;
}

/**
 * Prevent `sub` and `sup` affecting `line-height` in all browsers.
 */

sub,
sup {
    font-size: 75%;
    line-height: 0;
    position: relative;
    vertical-align: baseline;
}

sup {
    top: -0.5em;
}

sub {
    bottom: -0.25em;
}

/* ==========================================================================
   Lists
   ========================================================================== */

/**
 * Address margins set differently in IE 6/7.
 */

dl,
menu,
ol,
ul {
    margin: 1em 0;
}

dd {
    margin: 0 0 0 40px;
}

/**
 * Address paddings set differently in IE 6/7.
 */

menu,
ol,
ul {
    padding: 0 0 0 40px;
}

/**
 * Correct list images handled incorrectly in IE 7.
 */

nav ul,
nav ol {
    list-style: none;
    list-style-image: none;
}

/* ==========================================================================
   Embedded content
   ========================================================================== */

/**
 * 1. Remove border when inside `a` element in IE 6/7/8/9 and Firefox 3.
 * 2. Improve image quality when scaled in IE 7.
 */

img {
    border: 0; /* 1 */
    -ms-interpolation-mode: bicubic; /* 2 */
}

/**
 * Correct overflow displayed oddly in IE 9.
 */

svg:not(:root) {
    overflow: hidden;
}

/* ==========================================================================
   Figures
   ========================================================================== */

/**
 * Address margin not present in IE 6/7/8/9, Safari 5, and Opera 11.
 */

figure {
    margin: 0;
}

/* ==========================================================================
   Forms
   ========================================================================== */

/**
 * Correct margin displayed oddly in IE 6/7.
 */

form {
    margin: 0;
}

/**
 * Define consistent border, margin, and padding.
 */

fieldset {
    border: 1px solid #c0c0c0;
    margin: 0 2px;
    padding: 0.35em 0.625em 0.75em;
}

/**
 * 1. Correct color not being inherited in IE 6/7/8/9.
 * 2. Correct text not wrapping in Firefox 3.
 * 3. Correct alignment displayed oddly in IE 6/7.
 */

legend {
    border: 0; /* 1 */
    padding: 0;
    white-space: normal; /* 2 */
    *margin-left: -7px; /* 3 */
}

/**
 * 1. Correct font size not being inherited in all browsers.
 * 2. Address margins set differently in IE 6/7, Firefox 3+, Safari 5,
 *    and Chrome.
 * 3. Improve appearance and consistency in all browsers.
 */

button,
input,
select,
textarea {
    font-size: 100%; /* 1 */
    margin: 0; /* 2 */
    vertical-align: baseline; /* 3 */
    *vertical-align: middle; /* 3 */
}

/**
 * Address Firefox 3+ setting `line-height` on `input` using `!important` in
 * the UA stylesheet.
 */

button,
input {
    line-height: normal;
}

/**
 * Address inconsistent `text-transform` inheritance for `button` and `select`.
 * All other form control elements do not inherit `text-transform` values.
 * Correct `button` style inheritance in Chrome, Safari 5+, and IE 6+.
 * Correct `select` style inheritance in Firefox 4+ and Opera.
 */

button,
select {
    text-transform: none;
}

/**
 * 1. Avoid the WebKit bug in Android 4.0.* where (2) destroys native `audio`
 *    and `video` controls.
 * 2. Correct inability to style clickable `input` types in iOS.
 * 3. Improve usability and consistency of cursor style between image-type
 *    `input` and others.
 * 4. Remove inner spacing in IE 7 without affecting normal text inputs.
 *    Known issue: inner spacing remains in IE 6.
 */

button,
html input[type="button"], /* 1 */
input[type="reset"],
input[type="submit"] {
    -webkit-appearance: button; /* 2 */
    cursor: pointer; /* 3 */
    *overflow: visible;  /* 4 */
}

/**
 * Re-set default cursor for disabled elements.
 */

button[disabled],
html input[disabled] {
    cursor: default;
}

/**
 * 1. Address box sizing set to content-box in IE 8/9.
 * 2. Remove excess padding in IE 8/9.
 * 3. Remove excess padding in IE 7.
 *    Known issue: excess padding remains in IE 6.
 */

input[type="checkbox"],
input[type="radio"] {
    box-sizing: border-box; /* 1 */
    padding: 0; /* 2 */
    *height: 13px; /* 3 */
    *width: 13px; /* 3 */
}

/**
 * 1. Address `appearance` set to `searchfield` in Safari 5 and Chrome.
 * 2. Address `box-sizing` set to `border-box` in Safari 5 and Chrome
 *    (include `-moz` to future-proof).
 */

input[type="search"] {
    -webkit-appearance: textfield; /* 1 */
    -moz-box-sizing: content-box;
    -webkit-box-sizing: content-box; /* 2 */
    box-sizing: content-box;
}

/**
 * Remove inner padding and search cancel button in Safari 5 and Chrome
 * on OS X.
 */

input[type="search"]::-webkit-search-cancel-button,
input[type="search"]::-webkit-search-decoration {
    -webkit-appearance: none;
}

/**
 * Remove inner padding and border in Firefox 3+.
 */

button::-moz-focus-inner,
input::-moz-focus-inner {
    border: 0;
    padding: 0;
}

/**
 * 1. Remove default vertical scrollbar in IE 6/7/8/9.
 * 2. Improve readability and alignment in all browsers.
 */

textarea {
    overflow: auto; /* 1 */
    vertical-align: top; /* 2 */
}

/* ==========================================================================
   Tables
   ========================================================================== */

/**
 * Remove most spacing between table cells.
 */

table {
    border-collapse: collapse;
    border-spacing: 0;
}
</style>
  <style type="text/css">
  html, body {
    margin: 0;
    padding: 0;
    min-height: 100%;
  }
  body {
    background: #fff;
    font-family: "Source Sans Pro", "Helvetica Neueue", Helvetica, sans;
    font-weight: 300;
    font-size: 16px;
    line-height: 1.6em;
  }
  #content {
    width: 70%;
    max-width: 850px;
    float: left;
    padding: 30px 60px;
    border-left: 1px solid #ddd;
  }
  #sidebar {
    width: 25%;
    float: left;
    padding: 30px;
    overflow: hidden;
  }
  #nav {
    font-size: 130%;
    margin: 0 0 15px 0;
  }

  #top {
    display: block;
    position: fixed;
    bottom: 5px;
    left: 5px;
    font-size: .85em;
    text-transform: uppercase;
  }

  #footer {
    font-size: .75em;
    padding: 5px 30px;
    border-top: 1px solid #ddd;
    text-align: right;
  }
    #footer p {
      margin: 0 0 0 30px;
      display: inline-block;
    }

  h1, h2, h3, h4, h5 {
    font-weight: 300;
  }
  h1 {
    font-size: 2.5em;
    line-height: 1.1em;
    margin: 0 0 .50em 0;
  }

  h2 {
    font-size: 1.75em;
    margin: 1em 0 .50em 0;
  }

  h3 {
    margin: 25px 0 10px 0;
  }

  h4 {
    margin: 0;
    font-size: 105%;
  }

  a {
    color: #058;
    text-decoration: none;
    transition: color .3s ease-in-out;
  }

  a:hover {
    color: #e08524;
    transition: color .3s ease-in-out;
  }

  pre, code, .mono, .name {
    font-family: "Ubuntu Mono", "Cousine", "DejaVu Sans Mono", monospace;
  }

  .title .name {
    font-weight: bold;
  }
  .section-title {
    margin-top: 2em;
  }
  .ident {
    color: #900;
  }

  code {
    background: #f9f9f9;
  } 

  pre {
    background: #fefefe;
    border: 1px solid #ddd;
    box-shadow: 2px 2px 0 #f3f3f3;
    margin: 0 30px;
    padding: 15px 30px;
  }

  .codehilite {
    margin: 0 30px 10px 30px;
  }

    .codehilite pre {
      margin: 0;
    }
    .codehilite .err { background: #ff3300; color: #fff !important; } 

  table#module-list {
    font-size: 110%;
  }

    table#module-list tr td:first-child {
      padding-right: 10px;
      white-space: nowrap;
    }

    table#module-list td {
      vertical-align: top;
      padding-bottom: 8px;
    }

      table#module-list td p {
        margin: 0 0 7px 0;
      }

  .def {
    display: table;
  }

    .def p {
      display: table-cell;
      vertical-align: top;
      text-align: left;
    }

    .def p:first-child {
      white-space: nowrap;
    }

    .def p:last-child {
      width: 100%;
    }


  #index {
    list-style-type: none;
    margin: 0;
    padding: 0;
  }
    ul#index .class_name {
      /* font-size: 110%; */
      font-weight: bold;
    }
    #index ul {
      margin: 0;
    }

  .item {
    margin: 0 0 15px 0;
  }

    .item .class {
      margin: 0 0 25px 30px;
    }

      .item .class ul.class_list {
        margin: 0 0 20px 0;
      }

    .item .name {
      background: #fafafa;
      margin: 0;
      font-weight: bold;
      padding: 5px 10px;
      border-radius: 3px;
      display: inline-block;
      min-width: 40%;
    }
      .item .name:hover {
        background: #f6f6f6;
      }

    .item .empty_desc {
      margin: 0 0 5px 0;
      padding: 0;
    }

    .item .inheritance {
      margin: 3px 0 0 30px;
    }

    .item .inherited {
      color: #666;
    }

    .item .desc {
      padding: 0 8px;
      margin: 0;
    }

      .item .desc p {
        margin: 0 0 10px 0;
      }

    .source_cont {
      margin: 0;
      padding: 0;
    }

    .source_link a {
      background: #ffc300;
      font-weight: 400;
      font-size: .75em;
      text-transform: uppercase;
      color: #fff;
      text-shadow: 1px 1px 0 #f4b700;
      
      padding: 3px 8px;
      border-radius: 2px;
      transition: background .3s ease-in-out;
    }
      .source_link a:hover {
        background: #FF7200;
        text-shadow: none;
        transition: background .3s ease-in-out;
      }

    .source {
      display: none;
      max-height: 600px;
      overflow-y: scroll;
      margin-bottom: 15px;
    }

      .source .codehilite {
        margin: 0;
      }

  .desc h1, .desc h2, .desc h3 {
    font-size: 100% !important;
  }
  .clear {
    clear: both;
  }

  @media all and (max-width: 950px) {
    #sidebar {
      width: 35%;
    }
    #content {
      width: 65%;
    }
  }
  @media all and (max-width: 650px) {
    #top {
      display: none;
    }
    #sidebar {
      float: none;
      width: auto;
    }
    #content {
      float: none;
      width: auto;
      padding: 30px;
    }

    #index ul {
      padding: 0;
      margin-bottom: 15px;
    }
    #index ul li {
      display: inline-block;
      margin-right: 30px;
    }
    #footer {
      text-align: left;
    }
    #footer p {
      display: block;
      margin: inherit;
    }
  }

  /*****************************/
</style>
  <style type="text/css">
  .codehilite .hll { background-color: #ffffcc }
.codehilite  { background: #f8f8f8; }
.codehilite .c { color: #408080; font-style: italic } /* Comment */
.codehilite .err { border: 1px solid #FF0000 } /* Error */
.codehilite .k { color: #008000; font-weight: bold } /* Keyword */
.codehilite .o { color: #666666 } /* Operator */
.codehilite .ch { color: #408080; font-style: italic } /* Comment.Hashbang */
.codehilite .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.codehilite .cp { color: #BC7A00 } /* Comment.Preproc */
.codehilite .cpf { color: #408080; font-style: italic } /* Comment.PreprocFile */
.codehilite .c1 { color: #408080; font-style: italic } /* Comment.Single */
.codehilite .cs { color: #408080; font-style: italic } /* Comment.Special */
.codehilite .gd { color: #A00000 } /* Generic.Deleted */
.codehilite .ge { font-style: italic } /* Generic.Emph */
.codehilite .gr { color: #FF0000 } /* Generic.Error */
.codehilite .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.codehilite .gi { color: #00A000 } /* Generic.Inserted */
.codehilite .go { color: #888888 } /* Generic.Output */
.codehilite .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.codehilite .gs { font-weight: bold } /* Generic.Strong */
.codehilite .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.codehilite .gt { color: #0044DD } /* Generic.Traceback */
.codehilite .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.codehilite .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.codehilite .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.codehilite .kp { color: #008000 } /* Keyword.Pseudo */
.codehilite .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.codehilite .kt { color: #B00040 } /* Keyword.Type */
.codehilite .m { color: #666666 } /* Literal.Number */
.codehilite .s { color: #BA2121 } /* Literal.String */
.codehilite .na { color: #7D9029 } /* Name.Attribute */
.codehilite .nb { color: #008000 } /* Name.Builtin */
.codehilite .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.codehilite .no { color: #880000 } /* Name.Constant */
.codehilite .nd { color: #AA22FF } /* Name.Decorator */
.codehilite .ni { color: #999999; font-weight: bold } /* Name.Entity */
.codehilite .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.codehilite .nf { color: #0000FF } /* Name.Function */
.codehilite .nl { color: #A0A000 } /* Name.Label */
.codehilite .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.codehilite .nt { color: #008000; font-weight: bold } /* Name.Tag */
.codehilite .nv { color: #19177C } /* Name.Variable */
.codehilite .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.codehilite .w { color: #bbbbbb } /* Text.Whitespace */
.codehilite .mb { color: #666666 } /* Literal.Number.Bin */
.codehilite .mf { color: #666666 } /* Literal.Number.Float */
.codehilite .mh { color: #666666 } /* Literal.Number.Hex */
.codehilite .mi { color: #666666 } /* Literal.Number.Integer */
.codehilite .mo { color: #666666 } /* Literal.Number.Oct */
.codehilite .sa { color: #BA2121 } /* Literal.String.Affix */
.codehilite .sb { color: #BA2121 } /* Literal.String.Backtick */
.codehilite .sc { color: #BA2121 } /* Literal.String.Char */
.codehilite .dl { color: #BA2121 } /* Literal.String.Delimiter */
.codehilite .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.codehilite .s2 { color: #BA2121 } /* Literal.String.Double */
.codehilite .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.codehilite .sh { color: #BA2121 } /* Literal.String.Heredoc */
.codehilite .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.codehilite .sx { color: #008000 } /* Literal.String.Other */
.codehilite .sr { color: #BB6688 } /* Literal.String.Regex */
.codehilite .s1 { color: #BA2121 } /* Literal.String.Single */
.codehilite .ss { color: #19177C } /* Literal.String.Symbol */
.codehilite .bp { color: #008000 } /* Name.Builtin.Pseudo */
.codehilite .fm { color: #0000FF } /* Name.Function.Magic */
.codehilite .vc { color: #19177C } /* Name.Variable.Class */
.codehilite .vg { color: #19177C } /* Name.Variable.Global */
.codehilite .vi { color: #19177C } /* Name.Variable.Instance */
.codehilite .vm { color: #19177C } /* Name.Variable.Magic */
.codehilite .il { color: #666666 } /* Literal.Number.Integer.Long */
  </style>
  <style type="text/css">
/* ==========================================================================
   EXAMPLE Media Queries for Responsive Design.
   These examples override the primary ('mobile first') styles.
   Modify as content requires.
   ========================================================================== */

@media only screen and (min-width: 35em) {
    /* Style adjustments for viewports that meet the condition */
}

@media print,
       (-o-min-device-pixel-ratio: 5/4),
       (-webkit-min-device-pixel-ratio: 1.25),
       (min-resolution: 120dpi) {
    /* Style adjustments for high resolution devices */
}

/* ==========================================================================
   Print styles.
   Inlined to avoid required HTTP connection: h5bp.com/r
   ========================================================================== */

@media print {
    * {
        background: transparent !important;
        color: #000 !important; /* Black prints faster: h5bp.com/s */
        box-shadow: none !important;
        text-shadow: none !important;
    }

    a,
    a:visited {
        text-decoration: underline;
    }

    a[href]:after {
        content: " (" attr(href) ")";
    }

    abbr[title]:after {
        content: " (" attr(title) ")";
    }

    /*
     * Don't show links for images, or javascript/internal links
     */

    .ir a:after,
    a[href^="javascript:"]:after,
    a[href^="#"]:after {
        content: "";
    }

    pre,
    blockquote {
        border: 1px solid #999;
        page-break-inside: avoid;
    }

    thead {
        display: table-header-group; /* h5bp.com/t */
    }

    tr,
    img {
        page-break-inside: avoid;
    }

    img {
        max-width: 100% !important;
    }

    @page {
        margin: 0.5cm;
    }

    p,
    h2,
    h3 {
        orphans: 3;
        widows: 3;
    }

    h2,
    h3 {
        page-break-after: avoid;
    }
}
</style>

  <script type="text/javascript">
  function toggle(id, $link) {
    $node = document.getElementById(id);
    if (!$node)
    return;
    if (!$node.style.display || $node.style.display == 'none') {
    $node.style.display = 'block';
    $link.innerHTML = 'Hide source &nequiv;';
    } else {
    $node.style.display = 'none';
    $link.innerHTML = 'Show source &equiv;';
    }
  }
  </script>
</head>
<body>
<a href="#" id="top">Top</a>
<div id="container">
  


















  
  <div id="sidebar">
    <h1>Index</h1>
    <ul id="index">
    <li class="set"><h3><a href="#header-variables">Module variables</a></h3>
      
  <ul>
    <li class="mono"><a href="#markovify.BEGIN">BEGIN</a></li>
    <li class="mono"><a href="#markovify.DEFAULT_MAX_OVERLAP_RATIO">DEFAULT_MAX_OVERLAP_RATIO</a></li>
    <li class="mono"><a href="#markovify.DEFAULT_MAX_OVERLAP_TOTAL">DEFAULT_MAX_OVERLAP_TOTAL</a></li>
    <li class="mono"><a href="#markovify.DEFAULT_TRIES">DEFAULT_TRIES</a></li>
    <li class="mono"><a href="#markovify.END">END</a></li>
    <li class="mono"><a href="#markovify.abbr_capped">abbr_capped</a></li>
    <li class="mono"><a href="#markovify.abbr_lowercase">abbr_lowercase</a></li>
    <li class="mono"><a href="#markovify.initialism_pat">initialism_pat</a></li>
    <li class="mono"><a href="#markovify.uppercase_letter_pat">uppercase_letter_pat</a></li>
  </ul>

    </li>

    <li class="set"><h3><a href="#header-functions">Functions</a></h3>
      
  <ul>
    <li class="mono"><a href="#markovify.accumulate">accumulate</a></li>
    <li class="mono"><a href="#markovify.combine">combine</a></li>
    <li class="mono"><a href="#markovify.compile_next">compile_next</a></li>
    <li class="mono"><a href="#markovify.get_model_dict">get_model_dict</a></li>
    <li class="mono"><a href="#markovify.is_abbreviation">is_abbreviation</a></li>
    <li class="mono"><a href="#markovify.is_sentence_ender">is_sentence_ender</a></li>
    <li class="mono"><a href="#markovify.split_into_sentences">split_into_sentences</a></li>
  </ul>

    </li>

    <li class="set"><h3><a href="#header-classes">Classes</a></h3>
      <ul>
        <li class="mono">
        <span class="class_name"><a href="#markovify.Chain">Chain</a></span>
        
          
  <ul>
    <li class="mono"><a href="#markovify.Chain.from_json">from_json</a></li>
    <li class="mono"><a href="#markovify.Chain.build">build</a></li>
    <li class="mono"><a href="#markovify.Chain.compile">compile</a></li>
    <li class="mono"><a href="#markovify.Chain.gen">gen</a></li>
    <li class="mono"><a href="#markovify.Chain.move">move</a></li>
    <li class="mono"><a href="#markovify.Chain.precompute_begin_state">precompute_begin_state</a></li>
    <li class="mono"><a href="#markovify.Chain.to_json">to_json</a></li>
    <li class="mono"><a href="#markovify.Chain.walk">walk</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#markovify.NewlineText">NewlineText</a></span>
        
          
  <ul>
    <li class="mono"><a href="#markovify.NewlineText.from_chain">from_chain</a></li>
    <li class="mono"><a href="#markovify.NewlineText.from_dict">from_dict</a></li>
    <li class="mono"><a href="#markovify.NewlineText.from_json">from_json</a></li>
    <li class="mono"><a href="#markovify.NewlineText.compile">compile</a></li>
    <li class="mono"><a href="#markovify.NewlineText.generate_corpus">generate_corpus</a></li>
    <li class="mono"><a href="#markovify.NewlineText.make_sentence">make_sentence</a></li>
    <li class="mono"><a href="#markovify.NewlineText.make_sentence_with_start">make_sentence_with_start</a></li>
    <li class="mono"><a href="#markovify.NewlineText.make_short_sentence">make_short_sentence</a></li>
    <li class="mono"><a href="#markovify.NewlineText.sentence_join">sentence_join</a></li>
    <li class="mono"><a href="#markovify.NewlineText.sentence_split">sentence_split</a></li>
    <li class="mono"><a href="#markovify.NewlineText.test_sentence_input">test_sentence_input</a></li>
    <li class="mono"><a href="#markovify.NewlineText.test_sentence_output">test_sentence_output</a></li>
    <li class="mono"><a href="#markovify.NewlineText.to_dict">to_dict</a></li>
    <li class="mono"><a href="#markovify.NewlineText.to_json">to_json</a></li>
    <li class="mono"><a href="#markovify.NewlineText.word_join">word_join</a></li>
    <li class="mono"><a href="#markovify.NewlineText.word_split">word_split</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#markovify.ParamError">ParamError</a></span>
        
          
  <ul>
    <li class="mono"><a href="#markovify.ParamError.with_traceback">with_traceback</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#markovify.Text">Text</a></span>
        
          
  <ul>
    <li class="mono"><a href="#markovify.Text.from_chain">from_chain</a></li>
    <li class="mono"><a href="#markovify.Text.from_dict">from_dict</a></li>
    <li class="mono"><a href="#markovify.Text.from_json">from_json</a></li>
    <li class="mono"><a href="#markovify.Text.compile">compile</a></li>
    <li class="mono"><a href="#markovify.Text.generate_corpus">generate_corpus</a></li>
    <li class="mono"><a href="#markovify.Text.make_sentence">make_sentence</a></li>
    <li class="mono"><a href="#markovify.Text.make_sentence_with_start">make_sentence_with_start</a></li>
    <li class="mono"><a href="#markovify.Text.make_short_sentence">make_short_sentence</a></li>
    <li class="mono"><a href="#markovify.Text.sentence_join">sentence_join</a></li>
    <li class="mono"><a href="#markovify.Text.sentence_split">sentence_split</a></li>
    <li class="mono"><a href="#markovify.Text.test_sentence_input">test_sentence_input</a></li>
    <li class="mono"><a href="#markovify.Text.test_sentence_output">test_sentence_output</a></li>
    <li class="mono"><a href="#markovify.Text.to_dict">to_dict</a></li>
    <li class="mono"><a href="#markovify.Text.to_json">to_json</a></li>
    <li class="mono"><a href="#markovify.Text.word_join">word_join</a></li>
    <li class="mono"><a href="#markovify.Text.word_split">word_split</a></li>
  </ul>

        </li>
      </ul>
    </li>

    </ul>
  </div>

<article id="content">
  

  


  <header id="section-intro">
  <h1 class="title"><span class="name">markovify</span> module</h1>
  <p>markovify.py</p>
  
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-markovify', this);">Show source &equiv;</a></p>
  <div id="source-markovify" class="source">
    <div class="codehilite"><pre><span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;markovify.py&quot;&quot;&quot;</span>

<span class="c1">################################################################################</span>
<span class="c1">#</span>
<span class="c1"># Markovify stand-alone Python module (version 1.0)</span>
<span class="c1">#</span>
<span class="c1"># Based upon markovify package by @jsvine of GitHub:</span>
<span class="c1"># https://github.com/jsvine/markovify</span>
<span class="c1">#</span>
<span class="c1"># Used src code as of Dec 10, 2020 (c8eb4cf)</span>
<span class="c1">#</span>
<span class="c1"># Project Los Angeles</span>
<span class="c1"># Tegridy Code 2021</span>
<span class="c1">#</span>
<span class="c1">################################################################################</span>
<span class="c1">#</span>
<span class="c1"># Critical requirements/dependency:</span>
<span class="c1">#</span>
<span class="c1"># pip install unidecode</span>
<span class="c1">#</span>
<span class="c1">################################################################################</span>

<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">secrets</span>
<span class="kn">import</span> <span class="nn">operator</span>
<span class="kn">import</span> <span class="nn">bisect</span>
<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">re</span>

<span class="kn">from</span> <span class="nn">unidecode</span> <span class="kn">import</span> <span class="n">unidecode</span>

<span class="c1">################################################################################</span>

<span class="c1"># chain.py module</span>

<span class="c1"># Python3 compatibility</span>
<span class="k">try</span><span class="p">:</span> <span class="c1"># pragma: no cover</span>
    <span class="n">basestring</span>
<span class="k">except</span> <span class="ne">NameError</span><span class="p">:</span> <span class="c1"># pragma: no cover</span>
    <span class="n">basestring</span> <span class="o">=</span> <span class="nb">str</span>

<span class="n">BEGIN</span> <span class="o">=</span> <span class="s2">&quot;___BEGIN__&quot;</span>
<span class="n">END</span> <span class="o">=</span> <span class="s2">&quot;___END__&quot;</span>

<span class="k">def</span> <span class="nf">accumulate</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="n">operator</span><span class="o">.</span><span class="n">add</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Cumulative calculations. (Summation, by default.)</span>
<span class="sd">    Via: https://docs.python.org/3/library/itertools.html#itertools.accumulate</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">it</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">iterable</span><span class="p">)</span>
    <span class="n">total</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
    <span class="k">yield</span> <span class="n">total</span>
    <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">it</span><span class="p">:</span>
        <span class="n">total</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">total</span><span class="p">,</span> <span class="n">element</span><span class="p">)</span>
        <span class="k">yield</span> <span class="n">total</span>

<span class="k">def</span> <span class="nf">compile_next</span><span class="p">(</span><span class="n">next_dict</span><span class="p">):</span>
    <span class="n">words</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">next_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="n">cff</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">accumulate</span><span class="p">(</span><span class="n">next_dict</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">words</span><span class="p">,</span> <span class="n">cff</span><span class="p">]</span>

<span class="k">class</span> <span class="nc">Chain</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A Markov chain representing processes that have both beginnings and ends.</span>
<span class="sd">    For example: Sentences.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">corpus</span><span class="p">,</span> <span class="n">state_size</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        `corpus`: A list of lists, where each outer list is a &quot;run&quot;</span>
<span class="sd">        of the process (e.g., a single sentence), and each inner list</span>
<span class="sd">        contains the steps (e.g., words) in the run. If you want to simulate</span>
<span class="sd">        an infinite process, you can come very close by passing just one, very</span>
<span class="sd">        long run.</span>
<span class="sd">        `state_size`: An integer indicating the number of items the model</span>
<span class="sd">        uses to represent its state. For text generation, 2 or 3 are typical.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state_size</span> <span class="o">=</span> <span class="n">state_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">model</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">corpus</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">state_size</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compiled</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">[</span><span class="nb">tuple</span><span class="p">([</span><span class="n">BEGIN</span><span class="p">]</span><span class="o">*</span><span class="n">state_size</span><span class="p">)])</span> <span class="o">==</span> <span class="nb">list</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">compiled</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">precompute_begin_state</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">compile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inplace</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">compiled</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span> <span class="k">return</span> <span class="bp">self</span>
            <span class="k">return</span> <span class="n">Chain</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">state_size</span><span class="p">,</span> <span class="n">model</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">))</span>
        <span class="n">mdict</span> <span class="o">=</span> <span class="p">{</span> <span class="n">state</span><span class="p">:</span> <span class="n">compile_next</span><span class="p">(</span><span class="n">next_dict</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">next_dict</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="p">}</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">inplace</span><span class="p">:</span> <span class="k">return</span> <span class="n">Chain</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">state_size</span><span class="p">,</span> <span class="n">model</span> <span class="o">=</span> <span class="n">mdict</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">mdict</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compiled</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">build</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">corpus</span><span class="p">,</span> <span class="n">state_size</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build a Python representation of the Markov model. Returns a dict</span>
<span class="sd">        of dicts where the keys of the outer dict represent all possible states,</span>
<span class="sd">        and point to the inner dicts. The inner dicts represent all possibilities</span>
<span class="sd">        for the &quot;next&quot; item in the chain, along with the count of times it</span>
<span class="sd">        appears.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Using a DefaultDict here would be a lot more convenient, however the memory</span>
        <span class="c1"># usage is far higher.</span>
        <span class="n">model</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">run</span> <span class="ow">in</span> <span class="n">corpus</span><span class="p">:</span>
            <span class="n">items</span> <span class="o">=</span> <span class="p">([</span> <span class="n">BEGIN</span> <span class="p">]</span> <span class="o">*</span> <span class="n">state_size</span><span class="p">)</span> <span class="o">+</span> <span class="n">run</span> <span class="o">+</span> <span class="p">[</span> <span class="n">END</span> <span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">run</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">state</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">items</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="n">state_size</span><span class="p">])</span>
                <span class="n">follow</span> <span class="o">=</span> <span class="n">items</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">state_size</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">state</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">model</span><span class="p">:</span>
                    <span class="n">model</span><span class="p">[</span><span class="n">state</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

                <span class="k">if</span> <span class="n">follow</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">model</span><span class="p">[</span><span class="n">state</span><span class="p">]:</span>
                    <span class="n">model</span><span class="p">[</span><span class="n">state</span><span class="p">][</span><span class="n">follow</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

                <span class="n">model</span><span class="p">[</span><span class="n">state</span><span class="p">][</span><span class="n">follow</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">model</span>

    <span class="k">def</span> <span class="nf">precompute_begin_state</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Caches the summation calculation and available choices for BEGIN * state_size.</span>
<span class="sd">        Significantly speeds up chain generation on large corpora. Thanks, @schollz!</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">begin_state</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span> <span class="n">BEGIN</span> <span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">state_size</span><span class="p">)</span>
        <span class="n">choices</span><span class="p">,</span> <span class="n">cumdist</span> <span class="o">=</span> <span class="n">compile_next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">[</span><span class="n">begin_state</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">begin_cumdist</span> <span class="o">=</span> <span class="n">cumdist</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">begin_choices</span> <span class="o">=</span> <span class="n">choices</span>

    <span class="k">def</span> <span class="nf">move</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a state, choose the next item at random.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">compiled</span><span class="p">:</span>
            <span class="n">choices</span><span class="p">,</span> <span class="n">cumdist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">[</span><span class="n">state</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">state</span> <span class="o">==</span> <span class="nb">tuple</span><span class="p">([</span> <span class="n">BEGIN</span> <span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">state_size</span><span class="p">):</span>
            <span class="n">choices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">begin_choices</span>
            <span class="n">cumdist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">begin_cumdist</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">choices</span><span class="p">,</span> <span class="n">weights</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">[</span><span class="n">state</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
            <span class="n">cumdist</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">accumulate</span><span class="p">(</span><span class="n">weights</span><span class="p">))</span>
        <span class="c1"># r = random.random() * cumdist[-1]</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">secrets</span><span class="o">.</span><span class="n">choice</span><span class="p">([</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">(),</span> <span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()])</span> <span class="o">*</span> <span class="n">cumdist</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">selection</span> <span class="o">=</span> <span class="n">choices</span><span class="p">[</span><span class="n">bisect</span><span class="o">.</span><span class="n">bisect</span><span class="p">(</span><span class="n">cumdist</span><span class="p">,</span> <span class="n">r</span><span class="p">)]</span>
        <span class="k">return</span> <span class="n">selection</span>

    <span class="k">def</span> <span class="nf">gen</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">init_state</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Starting either with a naive BEGIN state, or the provided `init_state`</span>
<span class="sd">        (as a tuple), return a generator that will yield successive items</span>
<span class="sd">        until the chain reaches the END state.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">state</span> <span class="o">=</span> <span class="n">init_state</span> <span class="ow">or</span> <span class="p">(</span><span class="n">BEGIN</span><span class="p">,)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">state_size</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">next_word</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">next_word</span> <span class="o">==</span> <span class="n">END</span><span class="p">:</span> <span class="k">break</span>
            <span class="k">yield</span> <span class="n">next_word</span>
            <span class="n">state</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">state</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span> <span class="o">+</span> <span class="p">(</span><span class="n">next_word</span><span class="p">,)</span>

    <span class="k">def</span> <span class="nf">walk</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">init_state</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a list representing a single run of the Markov model, either</span>
<span class="sd">        starting with a naive BEGIN state, or the provided `init_state`</span>
<span class="sd">        (as a tuple).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gen</span><span class="p">(</span><span class="n">init_state</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">to_json</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Dump the model as a JSON object, for loading later.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">items</span><span class="p">()))</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_json</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">json_thing</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a JSON object or JSON string that was created by `self.to_json`,</span>
<span class="sd">        return the corresponding markovify.Chain.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">json_thing</span><span class="p">,</span> <span class="n">basestring</span><span class="p">):</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">json_thing</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">json_thing</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">rehydrated</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="nb">tuple</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">obj</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">rehydrated</span> <span class="o">=</span> <span class="n">obj</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Object should be dict or list&quot;</span><span class="p">)</span>

        <span class="n">state_size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">rehydrated</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">0</span><span class="p">])</span>

        <span class="n">inst</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">state_size</span><span class="p">,</span> <span class="n">rehydrated</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">inst</span>

<span class="c1">################################################################################</span>

<span class="c1"># splitters.py module</span>

<span class="n">uppercase_letter_pat</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;^[A-Z]$&quot;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">UNICODE</span><span class="p">)</span>
<span class="n">initialism_pat</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;^[A-Za-z0-9]{1,2}(\.[A-Za-z0-9]{1,2})+\.$&quot;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">UNICODE</span><span class="p">)</span>

<span class="c1"># States w/ with thanks to https://github.com/unitedstates/python-us</span>
<span class="c1"># Titles w/ thanks to https://github.com/nytimes/emphasis and @donohoe</span>
<span class="n">abbr_capped</span> <span class="o">=</span> <span class="s2">&quot;|&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span>
    <span class="s2">&quot;ala|ariz|ark|calif|colo|conn|del|fla|ga|ill|ind|kan|ky|la|md|mass|mich|minn|miss|mo|mont|neb|nev|okla|ore|pa|tenn|vt|va|wash|wis|wyo&quot;</span><span class="p">,</span> <span class="c1"># States</span>
    <span class="s2">&quot;u.s&quot;</span><span class="p">,</span>
    <span class="s2">&quot;mr|ms|mrs|msr|dr|gov|pres|sen|sens|rep|reps|prof|gen|messrs|col|sr|jf|sgt|mgr|fr|rev|jr|snr|atty|supt&quot;</span><span class="p">,</span> <span class="c1"># Titles</span>
    <span class="s2">&quot;ave|blvd|st|rd|hwy&quot;</span><span class="p">,</span> <span class="c1"># Streets</span>
    <span class="s2">&quot;jan|feb|mar|apr|jun|jul|aug|sep|sept|oct|nov|dec&quot;</span><span class="p">,</span> <span class="c1"># Months</span>
<span class="p">])</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;|&quot;</span><span class="p">)</span>

<span class="n">abbr_lowercase</span> <span class="o">=</span> <span class="s2">&quot;etc|v|vs|viz|al|pct&quot;</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;|&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">is_abbreviation</span><span class="p">(</span><span class="n">dotted_word</span><span class="p">):</span>
    <span class="n">clipped</span> <span class="o">=</span> <span class="n">dotted_word</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">uppercase_letter_pat</span><span class="p">,</span> <span class="n">clipped</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">clipped</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="c1"># Initial</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">clipped</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="n">abbr_capped</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">clipped</span> <span class="ow">in</span> <span class="n">abbr_lowercase</span><span class="p">:</span> <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span> <span class="k">return</span> <span class="kc">False</span>

<span class="k">def</span> <span class="nf">is_sentence_ender</span><span class="p">(</span><span class="n">word</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">initialism_pat</span><span class="p">,</span> <span class="n">word</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="k">return</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">word</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="p">[</span> <span class="s2">&quot;?&quot;</span><span class="p">,</span> <span class="s2">&quot;!&quot;</span> <span class="p">]:</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;[^A-Z]&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">word</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">if</span> <span class="n">word</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;.&quot;</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">is_abbreviation</span><span class="p">(</span><span class="n">word</span><span class="p">)):</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">return</span> <span class="kc">False</span>

<span class="k">def</span> <span class="nf">split_into_sentences</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
    <span class="n">potential_end_pat</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span>
        <span class="sa">r</span><span class="s2">&quot;([\w\.&#39;’&amp;\]\)]+[\.\?!])&quot;</span><span class="p">,</span> <span class="c1"># A word that ends with punctuation</span>
        <span class="sa">r</span><span class="s2">&quot;([‘’“”&#39;</span><span class="se">\&quot;</span><span class="s2">\)\]]*)&quot;</span><span class="p">,</span> <span class="c1"># Followed by optional quote/parens/etc</span>
        <span class="sa">r</span><span class="s2">&quot;(\s+(?![a-z\-–—]))&quot;</span><span class="p">,</span> <span class="c1"># Followed by whitespace + non-(lowercase or dash)</span>
        <span class="p">]),</span> <span class="n">re</span><span class="o">.</span><span class="n">U</span><span class="p">)</span>
    <span class="n">dot_iter</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">finditer</span><span class="p">(</span><span class="n">potential_end_pat</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>
    <span class="n">end_indices</span> <span class="o">=</span> <span class="p">[</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">start</span><span class="p">()</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">dot_iter</span>
        <span class="k">if</span> <span class="n">is_sentence_ender</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span> <span class="p">]</span>
    <span class="n">spans</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">([</span><span class="kc">None</span><span class="p">]</span> <span class="o">+</span> <span class="n">end_indices</span><span class="p">,</span> <span class="n">end_indices</span> <span class="o">+</span> <span class="p">[</span><span class="kc">None</span><span class="p">])</span>
    <span class="n">sentences</span> <span class="o">=</span> <span class="p">[</span> <span class="n">text</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="ow">in</span> <span class="n">spans</span> <span class="p">]</span>
    <span class="k">return</span> <span class="n">sentences</span>

<span class="c1">################################################################################</span>

<span class="c1"># text.py module</span>

<span class="n">DEFAULT_MAX_OVERLAP_RATIO</span> <span class="o">=</span> <span class="mf">0.7</span>
<span class="n">DEFAULT_MAX_OVERLAP_TOTAL</span> <span class="o">=</span> <span class="mi">15</span>
<span class="n">DEFAULT_TRIES</span> <span class="o">=</span> <span class="mi">10</span>

<span class="k">class</span> <span class="nc">ParamError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">Text</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="n">reject_pat</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(^&#39;)|(&#39;$)|\s&#39;|&#39;\s|[</span><span class="se">\&quot;</span><span class="s2">(\(\)\[\])]&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_text</span><span class="p">,</span> <span class="n">state_size</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">chain</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">parsed_sentences</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">retain_original</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">well_formed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">reject_reg</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        input_text: A string.</span>
<span class="sd">        state_size: An integer, indicating the number of words in the model&#39;s state.</span>
<span class="sd">        chain: A trained markovify.Chain instance for this text, if pre-processed.</span>
<span class="sd">        parsed_sentences: A list of lists, where each outer list is a &quot;run&quot;</span>
<span class="sd">              of the process (e.g. a single sentence), and each inner list</span>
<span class="sd">              contains the steps (e.g. words) in the run. If you want to simulate</span>
<span class="sd">              an infinite process, you can come very close by passing just one, very</span>
<span class="sd">              long run.</span>
<span class="sd">        retain_original: Indicates whether to keep the original corpus.</span>
<span class="sd">        well_formed: Indicates whether sentences should be well-formed, preventing</span>
<span class="sd">              unmatched quotes, parenthesis by default, or a custom regular expression</span>
<span class="sd">              can be provided.</span>
<span class="sd">        reject_reg: If well_formed is True, this can be provided to override the</span>
<span class="sd">              standard rejection pattern.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">well_formed</span> <span class="o">=</span> <span class="n">well_formed</span>
        <span class="k">if</span> <span class="n">well_formed</span> <span class="ow">and</span> <span class="n">reject_reg</span> <span class="o">!=</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reject_pat</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">reject_reg</span><span class="p">)</span>

        <span class="n">can_make_sentences</span> <span class="o">=</span> <span class="n">parsed_sentences</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">input_text</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">retain_original</span> <span class="o">=</span> <span class="n">retain_original</span> <span class="ow">and</span> <span class="n">can_make_sentences</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state_size</span> <span class="o">=</span> <span class="n">state_size</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">retain_original</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parsed_sentences</span> <span class="o">=</span> <span class="n">parsed_sentences</span> <span class="ow">or</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">generate_corpus</span><span class="p">(</span><span class="n">input_text</span><span class="p">))</span>

            <span class="c1"># Rejoined text lets us assess the novelty of generated sentences</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rejoined_text</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sentence_join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">word_join</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">parsed_sentences</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">chain</span> <span class="o">=</span> <span class="n">chain</span> <span class="ow">or</span> <span class="n">Chain</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parsed_sentences</span><span class="p">,</span> <span class="n">state_size</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">chain</span><span class="p">:</span>
                <span class="n">parsed</span> <span class="o">=</span> <span class="n">parsed_sentences</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_corpus</span><span class="p">(</span><span class="n">input_text</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">chain</span> <span class="o">=</span> <span class="n">chain</span> <span class="ow">or</span> <span class="n">Chain</span><span class="p">(</span><span class="n">parsed</span><span class="p">,</span> <span class="n">state_size</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">compile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inplace</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">inplace</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="n">cchain</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">inplace</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">psent</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;parsed_sentences&#39;</span><span class="p">):</span>
            <span class="n">psent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parsed_sentences</span>
        <span class="k">return</span> <span class="n">Text</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> \
                    <span class="n">state_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">state_size</span><span class="p">,</span> \
                    <span class="n">chain</span> <span class="o">=</span> <span class="n">cchain</span><span class="p">,</span> \
                    <span class="n">parsed_sentences</span> <span class="o">=</span> <span class="n">psent</span><span class="p">,</span> \
                    <span class="n">retain_original</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">retain_original</span><span class="p">,</span> \
                    <span class="n">well_formed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">well_formed</span><span class="p">,</span> \
                    <span class="n">reject_reg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reject_pat</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the underlying data as a Python dict.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s2">&quot;state_size&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">state_size</span><span class="p">,</span>
            <span class="s2">&quot;chain&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">to_json</span><span class="p">(),</span>
            <span class="s2">&quot;parsed_sentences&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">parsed_sentences</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">retain_original</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="p">}</span>

    <span class="k">def</span> <span class="nf">to_json</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the underlying data as a JSON string.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">to_dict</span><span class="p">())</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_dict</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span>
            <span class="kc">None</span><span class="p">,</span>
            <span class="n">state_size</span><span class="o">=</span><span class="n">obj</span><span class="p">[</span><span class="s2">&quot;state_size&quot;</span><span class="p">],</span>
            <span class="n">chain</span><span class="o">=</span><span class="n">Chain</span><span class="o">.</span><span class="n">from_json</span><span class="p">(</span><span class="n">obj</span><span class="p">[</span><span class="s2">&quot;chain&quot;</span><span class="p">]),</span>
            <span class="n">parsed_sentences</span><span class="o">=</span><span class="n">obj</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;parsed_sentences&quot;</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_json</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">json_str</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">json_str</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">sentence_split</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Splits full-text string into a list of sentences.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">split_into_sentences</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">sentence_join</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sentences</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Re-joins a list of sentences into the full text.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">sentences</span><span class="p">)</span>

    <span class="n">word_split_pattern</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\s+&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">word_split</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sentence</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Splits a sentence into a list of words.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">word_split_pattern</span><span class="p">,</span> <span class="n">sentence</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">word_join</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">words</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Re-joins a list of words into a sentence.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">words</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">test_sentence_input</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sentence</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A basic sentence filter. The default rejects sentences that contain</span>
<span class="sd">        the type of punctuation that would look strange on its own</span>
<span class="sd">        in a randomly-generated sentence.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sentence</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="kc">False</span>
        <span class="c1"># Decode unicode, mainly to normalize fancy quotation marks</span>
        <span class="k">if</span> <span class="n">sentence</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;str&quot;</span><span class="p">:</span> <span class="c1"># pragma: no cover</span>
            <span class="n">decoded</span> <span class="o">=</span> <span class="n">sentence</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1"># pragma: no cover</span>
            <span class="n">decoded</span> <span class="o">=</span> <span class="n">unidecode</span><span class="p">(</span><span class="n">sentence</span><span class="p">)</span>
        <span class="c1"># Sentence shouldn&#39;t contain problematic characters</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">well_formed</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">reject_pat</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">decoded</span><span class="p">):</span> <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">generate_corpus</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a text string, returns a list of lists; that is, a list of</span>
<span class="sd">        &quot;sentences,&quot; each of which is a list of words. Before splitting into</span>
<span class="sd">        words, the sentences are filtered through `self.test_sentence_input`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">sentences</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sentence_split</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sentences</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">text</span><span class="p">:</span>
                <span class="n">sentences</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sentence_split</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
        <span class="n">passing</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">test_sentence_input</span><span class="p">,</span> <span class="n">sentences</span><span class="p">)</span>
        <span class="n">runs</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">word_split</span><span class="p">,</span> <span class="n">passing</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">runs</span>

    <span class="k">def</span> <span class="nf">test_sentence_output</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">words</span><span class="p">,</span> <span class="n">max_overlap_ratio</span><span class="p">,</span> <span class="n">max_overlap_total</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a generated list of words, accept or reject it. This one rejects</span>
<span class="sd">        sentences that too closely match the original text, namely those that</span>
<span class="sd">        contain any identical sequence of words of X length, where X is the</span>
<span class="sd">        smaller number of (a) `max_overlap_ratio` (default: 0.7) of the total</span>
<span class="sd">        number of words, and (b) `max_overlap_total` (default: 15).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Reject large chunks of similarity</span>
        <span class="n">overlap_ratio</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">max_overlap_ratio</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">words</span><span class="p">)))</span>
        <span class="n">overlap_max</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">max_overlap_total</span><span class="p">,</span> <span class="n">overlap_ratio</span><span class="p">)</span>
        <span class="n">overlap_over</span> <span class="o">=</span> <span class="n">overlap_max</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">gram_count</span> <span class="o">=</span> <span class="nb">max</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">words</span><span class="p">)</span> <span class="o">-</span> <span class="n">overlap_max</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">grams</span> <span class="o">=</span> <span class="p">[</span> <span class="n">words</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="n">overlap_over</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">gram_count</span><span class="p">)</span> <span class="p">]</span>
        <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">grams</span><span class="p">:</span>
            <span class="n">gram_joined</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">word_join</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">gram_joined</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">rejoined_text</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">make_sentence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">init_state</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Attempts `tries` (default: 10) times to generate a valid sentence,</span>
<span class="sd">        based on the model and `test_sentence_output`. Passes `max_overlap_ratio`</span>
<span class="sd">        and `max_overlap_total` to `test_sentence_output`.</span>
<span class="sd">        If successful, returns the sentence as a string. If not, returns None.</span>
<span class="sd">        If `init_state` (a tuple of `self.chain.state_size` words) is not specified,</span>
<span class="sd">        this method chooses a sentence-start at random, in accordance with</span>
<span class="sd">        the model.</span>
<span class="sd">        If `test_output` is set as False then the `test_sentence_output` check</span>
<span class="sd">        will be skipped.</span>
<span class="sd">        If `max_words` or `min_words` are specified, the word count for the sentence will be</span>
<span class="sd">        evaluated against the provided limit(s).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tries</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;tries&#39;</span><span class="p">,</span> <span class="n">DEFAULT_TRIES</span><span class="p">)</span>
        <span class="n">mor</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;max_overlap_ratio&#39;</span><span class="p">,</span> <span class="n">DEFAULT_MAX_OVERLAP_RATIO</span><span class="p">)</span>
        <span class="n">mot</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;max_overlap_total&#39;</span><span class="p">,</span> <span class="n">DEFAULT_MAX_OVERLAP_TOTAL</span><span class="p">)</span>
        <span class="n">test_output</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;test_output&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">max_words</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;max_words&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">min_words</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;min_words&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">init_state</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">prefix</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">init_state</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">prefix</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">word</span> <span class="o">==</span> <span class="n">BEGIN</span><span class="p">:</span>
                    <span class="n">prefix</span> <span class="o">=</span> <span class="n">prefix</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">prefix</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">tries</span><span class="p">):</span>
            <span class="n">words</span> <span class="o">=</span> <span class="n">prefix</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">walk</span><span class="p">(</span><span class="n">init_state</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">max_words</span> <span class="o">!=</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">words</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">max_words</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">min_words</span> <span class="o">!=</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">words</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">min_words</span><span class="p">):</span>
                <span class="k">continue</span> <span class="c1"># pragma: no cover # see https://github.com/nedbat/coveragepy/issues/198</span>
            <span class="k">if</span> <span class="n">test_output</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;rejoined_text&quot;</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">test_sentence_output</span><span class="p">(</span><span class="n">words</span><span class="p">,</span> <span class="n">mor</span><span class="p">,</span> <span class="n">mot</span><span class="p">):</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">word_join</span><span class="p">(</span><span class="n">words</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">word_join</span><span class="p">(</span><span class="n">words</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">make_short_sentence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_chars</span><span class="p">,</span> <span class="n">min_chars</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Tries making a sentence of no more than `max_chars` characters and optionally</span>
<span class="sd">        no less than `min_chars` characters, passing **kwargs to `self.make_sentence`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tries</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;tries&#39;</span><span class="p">,</span> <span class="n">DEFAULT_TRIES</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">tries</span><span class="p">):</span>
            <span class="n">sentence</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_sentence</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">sentence</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">sentence</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">max_chars</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">sentence</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">min_chars</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">sentence</span>

    <span class="k">def</span> <span class="nf">make_sentence_with_start</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">beginning</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Tries making a sentence that begins with `beginning` string,</span>
<span class="sd">        which should be a string of one to `self.state` words known</span>
<span class="sd">        to exist in the corpus.</span>

<span class="sd">        If strict == True, then markovify will draw its initial inspiration</span>
<span class="sd">        only from sentences that start with the specified word/phrase.</span>
<span class="sd">        If strict == False, then markovify will draw its initial inspiration</span>
<span class="sd">        from any sentence containing the specified word/phrase.</span>
<span class="sd">        **kwargs are passed to `self.make_sentence`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">split</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">word_split</span><span class="p">(</span><span class="n">beginning</span><span class="p">))</span>
        <span class="n">word_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">split</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">word_count</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">state_size</span><span class="p">:</span>
            <span class="n">init_states</span> <span class="o">=</span> <span class="p">[</span> <span class="n">split</span> <span class="p">]</span>

        <span class="k">elif</span> <span class="n">word_count</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">word_count</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">state_size</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">strict</span><span class="p">:</span>
                <span class="n">init_states</span> <span class="o">=</span> <span class="p">[</span> <span class="p">(</span><span class="n">BEGIN</span><span class="p">,)</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state_size</span> <span class="o">-</span> <span class="n">word_count</span><span class="p">)</span> <span class="o">+</span> <span class="n">split</span> <span class="p">]</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">init_states</span> <span class="o">=</span> <span class="p">[</span> <span class="n">key</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
                    <span class="c1"># check for starting with begin as well ordered lists</span>
                    <span class="k">if</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">!=</span> <span class="n">BEGIN</span><span class="p">,</span> <span class="n">key</span><span class="p">))[:</span><span class="n">word_count</span><span class="p">]</span> <span class="o">==</span> <span class="n">split</span> <span class="p">]</span>

                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">secrets</span><span class="o">.</span><span class="n">choice</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])):</span>
                  <span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">init_states</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">err_msg</span> <span class="o">=</span> <span class="s2">&quot;`make_sentence_with_start` for this model requires a string containing 1 to </span><span class="si">{0}</span><span class="s2"> words. Yours has </span><span class="si">{1}</span><span class="s2">: </span><span class="si">{2}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state_size</span><span class="p">,</span> <span class="n">word_count</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">split</span><span class="p">))</span>
            <span class="k">raise</span> <span class="n">ParamError</span><span class="p">(</span><span class="n">err_msg</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">init_state</span> <span class="ow">in</span> <span class="n">init_states</span><span class="p">:</span>
            <span class="n">output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_sentence</span><span class="p">(</span><span class="n">init_state</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">output</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">output</span>
        <span class="n">err_msg</span> <span class="o">=</span> <span class="s2">&quot;`make_sentence_with_start` can&#39;t find sentence beginning with </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">beginning</span><span class="p">)</span>
        <span class="k">raise</span> <span class="n">ParamError</span><span class="p">(</span><span class="n">err_msg</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_chain</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">chain_json</span><span class="p">,</span> <span class="n">corpus</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">parsed_sentences</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Init a Text class based on an existing chain JSON string or object</span>
<span class="sd">        If corpus is None, overlap checking won&#39;t work.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">chain</span> <span class="o">=</span> <span class="n">Chain</span><span class="o">.</span><span class="n">from_json</span><span class="p">(</span><span class="n">chain_json</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">corpus</span> <span class="ow">or</span> <span class="kc">None</span><span class="p">,</span> <span class="n">parsed_sentences</span><span class="o">=</span><span class="n">parsed_sentences</span><span class="p">,</span> <span class="n">state_size</span><span class="o">=</span><span class="n">chain</span><span class="o">.</span><span class="n">state_size</span><span class="p">,</span> <span class="n">chain</span><span class="o">=</span><span class="n">chain</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">NewlineText</span><span class="p">(</span><span class="n">Text</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A (usable) example of subclassing markovify.Text. This one lets you markovify</span>
<span class="sd">    text where the sentences are separated by newlines instead of &quot;. &quot;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">sentence_split</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\s*\n\s*&quot;</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>

<span class="c1">################################################################################</span>

<span class="c1"># utils.py module</span>

<span class="k">def</span> <span class="nf">get_model_dict</span><span class="p">(</span><span class="n">thing</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">thing</span><span class="p">,</span> <span class="n">Chain</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">thing</span><span class="o">.</span><span class="n">compiled</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Not implemented for compiled markovify.Chain&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">thing</span><span class="o">.</span><span class="n">model</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">thing</span><span class="p">,</span> <span class="n">Text</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">thing</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">compiled</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Not implemented for compiled markovify.Chain&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">thing</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">model</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">thing</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">thing</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">thing</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">thing</span>

    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`models` should be instances of list, dict, markovify.Chain, or markovify.Text&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">combine</span><span class="p">(</span><span class="n">models</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">weights</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="p">[</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">models</span><span class="p">))</span> <span class="p">]</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">models</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">weights</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`models` and `weights` lengths must be equal.&quot;</span><span class="p">)</span>

    <span class="n">model_dicts</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">get_model_dict</span><span class="p">,</span> <span class="n">models</span><span class="p">))</span>
    <span class="n">state_sizes</span> <span class="o">=</span> <span class="p">[</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">md</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">md</span> <span class="ow">in</span> <span class="n">model_dicts</span> <span class="p">]</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">state_sizes</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;All `models` must have the same state size.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">type</span><span class="p">,</span> <span class="n">models</span><span class="p">)))</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;All `models` must be of the same type.&quot;</span><span class="p">)</span>

    <span class="n">c</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">for</span> <span class="n">m</span><span class="p">,</span> <span class="n">w</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">model_dicts</span><span class="p">,</span> <span class="n">weights</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">state</span><span class="p">,</span> <span class="n">options</span> <span class="ow">in</span> <span class="n">m</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">current</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="p">{})</span>
            <span class="k">for</span> <span class="n">subseq_k</span><span class="p">,</span> <span class="n">subseq_v</span> <span class="ow">in</span> <span class="n">options</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">subseq_prev</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">subseq_k</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">current</span><span class="p">[</span><span class="n">subseq_k</span><span class="p">]</span> <span class="o">=</span> <span class="n">subseq_prev</span> <span class="o">+</span> <span class="p">(</span><span class="n">subseq_v</span> <span class="o">*</span> <span class="n">w</span><span class="p">)</span>
            <span class="n">c</span><span class="p">[</span><span class="n">state</span><span class="p">]</span> <span class="o">=</span> <span class="n">current</span>

    <span class="n">ret_inst</span> <span class="o">=</span> <span class="n">models</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ret_inst</span><span class="p">,</span> <span class="n">Chain</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Chain</span><span class="o">.</span><span class="n">from_json</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ret_inst</span><span class="p">,</span> <span class="n">Text</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">retain_original</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">models</span><span class="p">):</span>
            <span class="n">combined_sentences</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">models</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">retain_original</span><span class="p">:</span>
                    <span class="n">combined_sentences</span> <span class="o">+=</span> <span class="n">m</span><span class="o">.</span><span class="n">parsed_sentences</span>
            <span class="k">return</span> <span class="n">ret_inst</span><span class="o">.</span><span class="n">from_chain</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">parsed_sentences</span><span class="o">=</span><span class="n">combined_sentences</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ret_inst</span><span class="o">.</span><span class="n">from_chain</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ret_inst</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ret_inst</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">c</span>
</pre></div>

  </div>

  </header>

  <section id="section-items">
    <h2 class="section-title" id="header-variables">Module variables</h2>
      <div class="item">
      <p id="markovify.BEGIN" class="name">var <span class="ident">BEGIN</span></p>
      
  
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="markovify.DEFAULT_MAX_OVERLAP_RATIO" class="name">var <span class="ident">DEFAULT_MAX_OVERLAP_RATIO</span></p>
      
  
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="markovify.DEFAULT_MAX_OVERLAP_TOTAL" class="name">var <span class="ident">DEFAULT_MAX_OVERLAP_TOTAL</span></p>
      
  
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="markovify.DEFAULT_TRIES" class="name">var <span class="ident">DEFAULT_TRIES</span></p>
      
  
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="markovify.END" class="name">var <span class="ident">END</span></p>
      
  
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="markovify.abbr_capped" class="name">var <span class="ident">abbr_capped</span></p>
      
  
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="markovify.abbr_lowercase" class="name">var <span class="ident">abbr_lowercase</span></p>
      
  
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="markovify.initialism_pat" class="name">var <span class="ident">initialism_pat</span></p>
      
  
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="markovify.uppercase_letter_pat" class="name">var <span class="ident">uppercase_letter_pat</span></p>
      
  
  <div class="source_cont">
</div>

      </div>

    <h2 class="section-title" id="header-functions">Functions</h2>
      
  <div class="item">
    <div class="name def" id="markovify.accumulate">
    <p>def <span class="ident">accumulate</span>(</p><p>iterable, func=&lt;built-in function add&gt;)</p>
    </div>
    

    
  
    <div class="desc"><p>Cumulative calculations. (Summation, by default.)
Via: https://docs.python.org/3/library/itertools.html#itertools.accumulate</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-markovify.accumulate', this);">Show source &equiv;</a></p>
  <div id="source-markovify.accumulate" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">accumulate</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="n">operator</span><span class="o">.</span><span class="n">add</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Cumulative calculations. (Summation, by default.)</span>
<span class="sd">    Via: https://docs.python.org/3/library/itertools.html#itertools.accumulate</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">it</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">iterable</span><span class="p">)</span>
    <span class="n">total</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
    <span class="k">yield</span> <span class="n">total</span>
    <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">it</span><span class="p">:</span>
        <span class="n">total</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">total</span><span class="p">,</span> <span class="n">element</span><span class="p">)</span>
        <span class="k">yield</span> <span class="n">total</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="markovify.combine">
    <p>def <span class="ident">combine</span>(</p><p>models, weights=None)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-markovify.combine', this);">Show source &equiv;</a></p>
  <div id="source-markovify.combine" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">combine</span><span class="p">(</span><span class="n">models</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">weights</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="p">[</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">models</span><span class="p">))</span> <span class="p">]</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">models</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">weights</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`models` and `weights` lengths must be equal.&quot;</span><span class="p">)</span>

    <span class="n">model_dicts</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">get_model_dict</span><span class="p">,</span> <span class="n">models</span><span class="p">))</span>
    <span class="n">state_sizes</span> <span class="o">=</span> <span class="p">[</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">md</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">md</span> <span class="ow">in</span> <span class="n">model_dicts</span> <span class="p">]</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">state_sizes</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;All `models` must have the same state size.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">type</span><span class="p">,</span> <span class="n">models</span><span class="p">)))</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;All `models` must be of the same type.&quot;</span><span class="p">)</span>

    <span class="n">c</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">for</span> <span class="n">m</span><span class="p">,</span> <span class="n">w</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">model_dicts</span><span class="p">,</span> <span class="n">weights</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">state</span><span class="p">,</span> <span class="n">options</span> <span class="ow">in</span> <span class="n">m</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">current</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="p">{})</span>
            <span class="k">for</span> <span class="n">subseq_k</span><span class="p">,</span> <span class="n">subseq_v</span> <span class="ow">in</span> <span class="n">options</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">subseq_prev</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">subseq_k</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">current</span><span class="p">[</span><span class="n">subseq_k</span><span class="p">]</span> <span class="o">=</span> <span class="n">subseq_prev</span> <span class="o">+</span> <span class="p">(</span><span class="n">subseq_v</span> <span class="o">*</span> <span class="n">w</span><span class="p">)</span>
            <span class="n">c</span><span class="p">[</span><span class="n">state</span><span class="p">]</span> <span class="o">=</span> <span class="n">current</span>

    <span class="n">ret_inst</span> <span class="o">=</span> <span class="n">models</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ret_inst</span><span class="p">,</span> <span class="n">Chain</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Chain</span><span class="o">.</span><span class="n">from_json</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ret_inst</span><span class="p">,</span> <span class="n">Text</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">retain_original</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">models</span><span class="p">):</span>
            <span class="n">combined_sentences</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">models</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">retain_original</span><span class="p">:</span>
                    <span class="n">combined_sentences</span> <span class="o">+=</span> <span class="n">m</span><span class="o">.</span><span class="n">parsed_sentences</span>
            <span class="k">return</span> <span class="n">ret_inst</span><span class="o">.</span><span class="n">from_chain</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">parsed_sentences</span><span class="o">=</span><span class="n">combined_sentences</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ret_inst</span><span class="o">.</span><span class="n">from_chain</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ret_inst</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ret_inst</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">c</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="markovify.compile_next">
    <p>def <span class="ident">compile_next</span>(</p><p>next_dict)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-markovify.compile_next', this);">Show source &equiv;</a></p>
  <div id="source-markovify.compile_next" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">compile_next</span><span class="p">(</span><span class="n">next_dict</span><span class="p">):</span>
    <span class="n">words</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">next_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="n">cff</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">accumulate</span><span class="p">(</span><span class="n">next_dict</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">words</span><span class="p">,</span> <span class="n">cff</span><span class="p">]</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="markovify.get_model_dict">
    <p>def <span class="ident">get_model_dict</span>(</p><p>thing)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-markovify.get_model_dict', this);">Show source &equiv;</a></p>
  <div id="source-markovify.get_model_dict" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">get_model_dict</span><span class="p">(</span><span class="n">thing</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">thing</span><span class="p">,</span> <span class="n">Chain</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">thing</span><span class="o">.</span><span class="n">compiled</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Not implemented for compiled markovify.Chain&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">thing</span><span class="o">.</span><span class="n">model</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">thing</span><span class="p">,</span> <span class="n">Text</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">thing</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">compiled</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Not implemented for compiled markovify.Chain&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">thing</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">model</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">thing</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">thing</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">thing</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">thing</span>

    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`models` should be instances of list, dict, markovify.Chain, or markovify.Text&quot;</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="markovify.is_abbreviation">
    <p>def <span class="ident">is_abbreviation</span>(</p><p>dotted_word)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-markovify.is_abbreviation', this);">Show source &equiv;</a></p>
  <div id="source-markovify.is_abbreviation" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">is_abbreviation</span><span class="p">(</span><span class="n">dotted_word</span><span class="p">):</span>
    <span class="n">clipped</span> <span class="o">=</span> <span class="n">dotted_word</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">uppercase_letter_pat</span><span class="p">,</span> <span class="n">clipped</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">clipped</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="c1"># Initial</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">clipped</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="n">abbr_capped</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">clipped</span> <span class="ow">in</span> <span class="n">abbr_lowercase</span><span class="p">:</span> <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span> <span class="k">return</span> <span class="kc">False</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="markovify.is_sentence_ender">
    <p>def <span class="ident">is_sentence_ender</span>(</p><p>word)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-markovify.is_sentence_ender', this);">Show source &equiv;</a></p>
  <div id="source-markovify.is_sentence_ender" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">is_sentence_ender</span><span class="p">(</span><span class="n">word</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">initialism_pat</span><span class="p">,</span> <span class="n">word</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="k">return</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">word</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="p">[</span> <span class="s2">&quot;?&quot;</span><span class="p">,</span> <span class="s2">&quot;!&quot;</span> <span class="p">]:</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;[^A-Z]&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">word</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">if</span> <span class="n">word</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;.&quot;</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">is_abbreviation</span><span class="p">(</span><span class="n">word</span><span class="p">)):</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">return</span> <span class="kc">False</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="markovify.split_into_sentences">
    <p>def <span class="ident">split_into_sentences</span>(</p><p>text)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-markovify.split_into_sentences', this);">Show source &equiv;</a></p>
  <div id="source-markovify.split_into_sentences" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">split_into_sentences</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
    <span class="n">potential_end_pat</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span>
        <span class="sa">r</span><span class="s2">&quot;([\w\.&#39;’&amp;\]\)]+[\.\?!])&quot;</span><span class="p">,</span> <span class="c1"># A word that ends with punctuation</span>
        <span class="sa">r</span><span class="s2">&quot;([‘’“”&#39;</span><span class="se">\&quot;</span><span class="s2">\)\]]*)&quot;</span><span class="p">,</span> <span class="c1"># Followed by optional quote/parens/etc</span>
        <span class="sa">r</span><span class="s2">&quot;(\s+(?![a-z\-–—]))&quot;</span><span class="p">,</span> <span class="c1"># Followed by whitespace + non-(lowercase or dash)</span>
        <span class="p">]),</span> <span class="n">re</span><span class="o">.</span><span class="n">U</span><span class="p">)</span>
    <span class="n">dot_iter</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">finditer</span><span class="p">(</span><span class="n">potential_end_pat</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>
    <span class="n">end_indices</span> <span class="o">=</span> <span class="p">[</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">start</span><span class="p">()</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">dot_iter</span>
        <span class="k">if</span> <span class="n">is_sentence_ender</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span> <span class="p">]</span>
    <span class="n">spans</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">([</span><span class="kc">None</span><span class="p">]</span> <span class="o">+</span> <span class="n">end_indices</span><span class="p">,</span> <span class="n">end_indices</span> <span class="o">+</span> <span class="p">[</span><span class="kc">None</span><span class="p">])</span>
    <span class="n">sentences</span> <span class="o">=</span> <span class="p">[</span> <span class="n">text</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="ow">in</span> <span class="n">spans</span> <span class="p">]</span>
    <span class="k">return</span> <span class="n">sentences</span>
</pre></div>

  </div>
</div>

  </div>
  

    <h2 class="section-title" id="header-classes">Classes</h2>
      
      <div class="item">
      <p id="markovify.Chain" class="name">class <span class="ident">Chain</span></p>
      
  
    <div class="desc"><p>A Markov chain representing processes that have both beginnings and ends.
For example: Sentences.</p></div>
  <div class="source_cont">
</div>


      <div class="class">
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="markovify.Chain.from_json">
    <p>def <span class="ident">from_json</span>(</p><p>json_thing)</p>
    </div>
    

    
  
    <div class="desc"><p>Given a JSON object or JSON string that was created by <code>self.to_json</code>,
return the corresponding markovify.Chain.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-markovify.Chain.from_json', this);">Show source &equiv;</a></p>
  <div id="source-markovify.Chain.from_json" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@classmethod</span>
<span class="k">def</span> <span class="nf">from_json</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">json_thing</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a JSON object or JSON string that was created by `self.to_json`,</span>
<span class="sd">    return the corresponding markovify.Chain.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">json_thing</span><span class="p">,</span> <span class="n">basestring</span><span class="p">):</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">json_thing</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="n">json_thing</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">rehydrated</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="nb">tuple</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">obj</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="n">rehydrated</span> <span class="o">=</span> <span class="n">obj</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Object should be dict or list&quot;</span><span class="p">)</span>
    <span class="n">state_size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">rehydrated</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">inst</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">state_size</span><span class="p">,</span> <span class="n">rehydrated</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">inst</span>
</pre></div>

  </div>
</div>

  </div>
  
          <h3>Methods</h3>
            
  <div class="item">
    <div class="name def" id="markovify.Chain.build">
    <p>def <span class="ident">build</span>(</p><p>self, corpus, state_size)</p>
    </div>
    

    
  
    <div class="desc"><p>Build a Python representation of the Markov model. Returns a dict
of dicts where the keys of the outer dict represent all possible states,
and point to the inner dicts. The inner dicts represent all possibilities
for the "next" item in the chain, along with the count of times it
appears.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-markovify.Chain.build', this);">Show source &equiv;</a></p>
  <div id="source-markovify.Chain.build" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">build</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">corpus</span><span class="p">,</span> <span class="n">state_size</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Build a Python representation of the Markov model. Returns a dict</span>
<span class="sd">    of dicts where the keys of the outer dict represent all possible states,</span>
<span class="sd">    and point to the inner dicts. The inner dicts represent all possibilities</span>
<span class="sd">    for the &quot;next&quot; item in the chain, along with the count of times it</span>
<span class="sd">    appears.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Using a DefaultDict here would be a lot more convenient, however the memory</span>
    <span class="c1"># usage is far higher.</span>
    <span class="n">model</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">run</span> <span class="ow">in</span> <span class="n">corpus</span><span class="p">:</span>
        <span class="n">items</span> <span class="o">=</span> <span class="p">([</span> <span class="n">BEGIN</span> <span class="p">]</span> <span class="o">*</span> <span class="n">state_size</span><span class="p">)</span> <span class="o">+</span> <span class="n">run</span> <span class="o">+</span> <span class="p">[</span> <span class="n">END</span> <span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">run</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">state</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">items</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="n">state_size</span><span class="p">])</span>
            <span class="n">follow</span> <span class="o">=</span> <span class="n">items</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">state_size</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">state</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">model</span><span class="p">:</span>
                <span class="n">model</span><span class="p">[</span><span class="n">state</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">if</span> <span class="n">follow</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">model</span><span class="p">[</span><span class="n">state</span><span class="p">]:</span>
                <span class="n">model</span><span class="p">[</span><span class="n">state</span><span class="p">][</span><span class="n">follow</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">model</span><span class="p">[</span><span class="n">state</span><span class="p">][</span><span class="n">follow</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">model</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="markovify.Chain.compile">
    <p>def <span class="ident">compile</span>(</p><p>self, inplace=False)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-markovify.Chain.compile', this);">Show source &equiv;</a></p>
  <div id="source-markovify.Chain.compile" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">compile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inplace</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">compiled</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span> <span class="k">return</span> <span class="bp">self</span>
        <span class="k">return</span> <span class="n">Chain</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">state_size</span><span class="p">,</span> <span class="n">model</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">))</span>
    <span class="n">mdict</span> <span class="o">=</span> <span class="p">{</span> <span class="n">state</span><span class="p">:</span> <span class="n">compile_next</span><span class="p">(</span><span class="n">next_dict</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">next_dict</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="p">}</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">inplace</span><span class="p">:</span> <span class="k">return</span> <span class="n">Chain</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">state_size</span><span class="p">,</span> <span class="n">model</span> <span class="o">=</span> <span class="n">mdict</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">mdict</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">compiled</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">return</span> <span class="bp">self</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="markovify.Chain.gen">
    <p>def <span class="ident">gen</span>(</p><p>self, init_state=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Starting either with a naive BEGIN state, or the provided <code>init_state</code>
(as a tuple), return a generator that will yield successive items
until the chain reaches the END state.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-markovify.Chain.gen', this);">Show source &equiv;</a></p>
  <div id="source-markovify.Chain.gen" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">gen</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">init_state</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Starting either with a naive BEGIN state, or the provided `init_state`</span>
<span class="sd">    (as a tuple), return a generator that will yield successive items</span>
<span class="sd">    until the chain reaches the END state.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">state</span> <span class="o">=</span> <span class="n">init_state</span> <span class="ow">or</span> <span class="p">(</span><span class="n">BEGIN</span><span class="p">,)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">state_size</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">next_word</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">next_word</span> <span class="o">==</span> <span class="n">END</span><span class="p">:</span> <span class="k">break</span>
        <span class="k">yield</span> <span class="n">next_word</span>
        <span class="n">state</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">state</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span> <span class="o">+</span> <span class="p">(</span><span class="n">next_word</span><span class="p">,)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="markovify.Chain.move">
    <p>def <span class="ident">move</span>(</p><p>self, state)</p>
    </div>
    

    
  
    <div class="desc"><p>Given a state, choose the next item at random.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-markovify.Chain.move', this);">Show source &equiv;</a></p>
  <div id="source-markovify.Chain.move" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">move</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a state, choose the next item at random.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">compiled</span><span class="p">:</span>
        <span class="n">choices</span><span class="p">,</span> <span class="n">cumdist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">[</span><span class="n">state</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">state</span> <span class="o">==</span> <span class="nb">tuple</span><span class="p">([</span> <span class="n">BEGIN</span> <span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">state_size</span><span class="p">):</span>
        <span class="n">choices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">begin_choices</span>
        <span class="n">cumdist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">begin_cumdist</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">choices</span><span class="p">,</span> <span class="n">weights</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">[</span><span class="n">state</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
        <span class="n">cumdist</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">accumulate</span><span class="p">(</span><span class="n">weights</span><span class="p">))</span>
    <span class="c1"># r = random.random() * cumdist[-1]</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">secrets</span><span class="o">.</span><span class="n">choice</span><span class="p">([</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">(),</span> <span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()])</span> <span class="o">*</span> <span class="n">cumdist</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">selection</span> <span class="o">=</span> <span class="n">choices</span><span class="p">[</span><span class="n">bisect</span><span class="o">.</span><span class="n">bisect</span><span class="p">(</span><span class="n">cumdist</span><span class="p">,</span> <span class="n">r</span><span class="p">)]</span>
    <span class="k">return</span> <span class="n">selection</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="markovify.Chain.precompute_begin_state">
    <p>def <span class="ident">precompute_begin_state</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Caches the summation calculation and available choices for BEGIN * state_size.
Significantly speeds up chain generation on large corpora. Thanks, @schollz!</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-markovify.Chain.precompute_begin_state', this);">Show source &equiv;</a></p>
  <div id="source-markovify.Chain.precompute_begin_state" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">precompute_begin_state</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Caches the summation calculation and available choices for BEGIN * state_size.</span>
<span class="sd">    Significantly speeds up chain generation on large corpora. Thanks, @schollz!</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">begin_state</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span> <span class="n">BEGIN</span> <span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">state_size</span><span class="p">)</span>
    <span class="n">choices</span><span class="p">,</span> <span class="n">cumdist</span> <span class="o">=</span> <span class="n">compile_next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">[</span><span class="n">begin_state</span><span class="p">])</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">begin_cumdist</span> <span class="o">=</span> <span class="n">cumdist</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">begin_choices</span> <span class="o">=</span> <span class="n">choices</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="markovify.Chain.to_json">
    <p>def <span class="ident">to_json</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Dump the model as a JSON object, for loading later.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-markovify.Chain.to_json', this);">Show source &equiv;</a></p>
  <div id="source-markovify.Chain.to_json" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">to_json</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Dump the model as a JSON object, for loading later.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">items</span><span class="p">()))</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="markovify.Chain.walk">
    <p>def <span class="ident">walk</span>(</p><p>self, init_state=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Return a list representing a single run of the Markov model, either
starting with a naive BEGIN state, or the provided <code>init_state</code>
(as a tuple).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-markovify.Chain.walk', this);">Show source &equiv;</a></p>
  <div id="source-markovify.Chain.walk" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">walk</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">init_state</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a list representing a single run of the Markov model, either</span>
<span class="sd">    starting with a naive BEGIN state, or the provided `init_state`</span>
<span class="sd">    (as a tuple).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gen</span><span class="p">(</span><span class="n">init_state</span><span class="p">))</span>
</pre></div>

  </div>
</div>

  </div>
  
      </div>
      </div>
      
      <div class="item">
      <p id="markovify.NewlineText" class="name">class <span class="ident">NewlineText</span></p>
      
  
    <div class="desc"><p>A (usable) example of subclassing markovify.Text. This one lets you markovify
text where the sentences are separated by newlines instead of ". "</p></div>
  <div class="source_cont">
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#markovify.Text">Text</a></li>
          </ul>
          <h3>Class variables</h3>
            <div class="item">
            <p id="markovify.NewlineText.reject_pat" class="name">var <span class="ident">reject_pat</span></p>
            
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#markovify.Text">Text</a></code>.<code><a href="#markovify.Text.reject_pat">reject_pat</a></code>
    </p>

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="markovify.NewlineText.word_split_pattern" class="name">var <span class="ident">word_split_pattern</span></p>
            
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#markovify.Text">Text</a></code>.<code><a href="#markovify.Text.word_split_pattern">word_split_pattern</a></code>
    </p>

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="markovify.NewlineText.from_chain">
    <p>def <span class="ident">from_chain</span>(</p><p>chain_json, corpus=None, parsed_sentences=None)</p>
    </div>
    
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#markovify.Text">Text</a></code>.<code><a href="#markovify.Text.from_chain">from_chain</a></code>
    </p>

    
  
    <div class="desc inherited"><p>Init a Text class based on an existing chain JSON string or object
If corpus is None, overlap checking won't work.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-markovify.NewlineText.from_chain', this);">Show source &equiv;</a></p>
  <div id="source-markovify.NewlineText.from_chain" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@classmethod</span>
<span class="k">def</span> <span class="nf">from_chain</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">chain_json</span><span class="p">,</span> <span class="n">corpus</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">parsed_sentences</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Init a Text class based on an existing chain JSON string or object</span>
<span class="sd">    If corpus is None, overlap checking won&#39;t work.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">chain</span> <span class="o">=</span> <span class="n">Chain</span><span class="o">.</span><span class="n">from_json</span><span class="p">(</span><span class="n">chain_json</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">corpus</span> <span class="ow">or</span> <span class="kc">None</span><span class="p">,</span> <span class="n">parsed_sentences</span><span class="o">=</span><span class="n">parsed_sentences</span><span class="p">,</span> <span class="n">state_size</span><span class="o">=</span><span class="n">chain</span><span class="o">.</span><span class="n">state_size</span><span class="p">,</span> <span class="n">chain</span><span class="o">=</span><span class="n">chain</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="markovify.NewlineText.from_dict">
    <p>def <span class="ident">from_dict</span>(</p><p>obj, **kwargs)</p>
    </div>
    
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#markovify.Text">Text</a></code>.<code><a href="#markovify.Text.from_dict">from_dict</a></code>
    </p>

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-markovify.NewlineText.from_dict', this);">Show source &equiv;</a></p>
  <div id="source-markovify.NewlineText.from_dict" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@classmethod</span>
<span class="k">def</span> <span class="nf">from_dict</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span>
        <span class="kc">None</span><span class="p">,</span>
        <span class="n">state_size</span><span class="o">=</span><span class="n">obj</span><span class="p">[</span><span class="s2">&quot;state_size&quot;</span><span class="p">],</span>
        <span class="n">chain</span><span class="o">=</span><span class="n">Chain</span><span class="o">.</span><span class="n">from_json</span><span class="p">(</span><span class="n">obj</span><span class="p">[</span><span class="s2">&quot;chain&quot;</span><span class="p">]),</span>
        <span class="n">parsed_sentences</span><span class="o">=</span><span class="n">obj</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;parsed_sentences&quot;</span><span class="p">)</span>
    <span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="markovify.NewlineText.from_json">
    <p>def <span class="ident">from_json</span>(</p><p>json_str)</p>
    </div>
    
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#markovify.Text">Text</a></code>.<code><a href="#markovify.Text.from_json">from_json</a></code>
    </p>

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-markovify.NewlineText.from_json', this);">Show source &equiv;</a></p>
  <div id="source-markovify.NewlineText.from_json" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@classmethod</span>
<span class="k">def</span> <span class="nf">from_json</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">json_str</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">json_str</span><span class="p">))</span>
</pre></div>

  </div>
</div>

  </div>
  
          <h3>Methods</h3>
            
  <div class="item">
    <div class="name def" id="markovify.NewlineText.compile">
    <p>def <span class="ident">compile</span>(</p><p>self, inplace=False)</p>
    </div>
    
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#markovify.Text">Text</a></code>.<code><a href="#markovify.Text.compile">compile</a></code>
    </p>

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-markovify.NewlineText.compile', this);">Show source &equiv;</a></p>
  <div id="source-markovify.NewlineText.compile" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">compile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inplace</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">inplace</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>
    <span class="n">cchain</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">inplace</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
    <span class="n">psent</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;parsed_sentences&#39;</span><span class="p">):</span>
        <span class="n">psent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parsed_sentences</span>
    <span class="k">return</span> <span class="n">Text</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> \
                <span class="n">state_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">state_size</span><span class="p">,</span> \
                <span class="n">chain</span> <span class="o">=</span> <span class="n">cchain</span><span class="p">,</span> \
                <span class="n">parsed_sentences</span> <span class="o">=</span> <span class="n">psent</span><span class="p">,</span> \
                <span class="n">retain_original</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">retain_original</span><span class="p">,</span> \
                <span class="n">well_formed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">well_formed</span><span class="p">,</span> \
                <span class="n">reject_reg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reject_pat</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="markovify.NewlineText.generate_corpus">
    <p>def <span class="ident">generate_corpus</span>(</p><p>self, text)</p>
    </div>
    
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#markovify.Text">Text</a></code>.<code><a href="#markovify.Text.generate_corpus">generate_corpus</a></code>
    </p>

    
  
    <div class="desc inherited"><p>Given a text string, returns a list of lists; that is, a list of
"sentences," each of which is a list of words. Before splitting into
words, the sentences are filtered through <code>self.test_sentence_input</code></p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-markovify.NewlineText.generate_corpus', this);">Show source &equiv;</a></p>
  <div id="source-markovify.NewlineText.generate_corpus" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">generate_corpus</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a text string, returns a list of lists; that is, a list of</span>
<span class="sd">    &quot;sentences,&quot; each of which is a list of words. Before splitting into</span>
<span class="sd">    words, the sentences are filtered through `self.test_sentence_input`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">sentences</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sentence_split</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">sentences</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">text</span><span class="p">:</span>
            <span class="n">sentences</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sentence_split</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
    <span class="n">passing</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">test_sentence_input</span><span class="p">,</span> <span class="n">sentences</span><span class="p">)</span>
    <span class="n">runs</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">word_split</span><span class="p">,</span> <span class="n">passing</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">runs</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="markovify.NewlineText.make_sentence">
    <p>def <span class="ident">make_sentence</span>(</p><p>self, init_state=None, **kwargs)</p>
    </div>
    
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#markovify.Text">Text</a></code>.<code><a href="#markovify.Text.make_sentence">make_sentence</a></code>
    </p>

    
  
    <div class="desc inherited"><p>Attempts <code>tries</code> (default: 10) times to generate a valid sentence,
based on the model and <code>test_sentence_output</code>. Passes <code>max_overlap_ratio</code>
and <code>max_overlap_total</code> to <code>test_sentence_output</code>.
If successful, returns the sentence as a string. If not, returns None.
If <code>init_state</code> (a tuple of <code>self.chain.state_size</code> words) is not specified,
this method chooses a sentence-start at random, in accordance with
the model.
If <code>test_output</code> is set as False then the <code>test_sentence_output</code> check
will be skipped.
If <code>max_words</code> or <code>min_words</code> are specified, the word count for the sentence will be
evaluated against the provided limit(s).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-markovify.NewlineText.make_sentence', this);">Show source &equiv;</a></p>
  <div id="source-markovify.NewlineText.make_sentence" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">make_sentence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">init_state</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Attempts `tries` (default: 10) times to generate a valid sentence,</span>
<span class="sd">    based on the model and `test_sentence_output`. Passes `max_overlap_ratio`</span>
<span class="sd">    and `max_overlap_total` to `test_sentence_output`.</span>
<span class="sd">    If successful, returns the sentence as a string. If not, returns None.</span>
<span class="sd">    If `init_state` (a tuple of `self.chain.state_size` words) is not specified,</span>
<span class="sd">    this method chooses a sentence-start at random, in accordance with</span>
<span class="sd">    the model.</span>
<span class="sd">    If `test_output` is set as False then the `test_sentence_output` check</span>
<span class="sd">    will be skipped.</span>
<span class="sd">    If `max_words` or `min_words` are specified, the word count for the sentence will be</span>
<span class="sd">    evaluated against the provided limit(s).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">tries</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;tries&#39;</span><span class="p">,</span> <span class="n">DEFAULT_TRIES</span><span class="p">)</span>
    <span class="n">mor</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;max_overlap_ratio&#39;</span><span class="p">,</span> <span class="n">DEFAULT_MAX_OVERLAP_RATIO</span><span class="p">)</span>
    <span class="n">mot</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;max_overlap_total&#39;</span><span class="p">,</span> <span class="n">DEFAULT_MAX_OVERLAP_TOTAL</span><span class="p">)</span>
    <span class="n">test_output</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;test_output&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
    <span class="n">max_words</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;max_words&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">min_words</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;min_words&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">init_state</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">prefix</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">init_state</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">prefix</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">word</span> <span class="o">==</span> <span class="n">BEGIN</span><span class="p">:</span>
                <span class="n">prefix</span> <span class="o">=</span> <span class="n">prefix</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">break</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">prefix</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">tries</span><span class="p">):</span>
        <span class="n">words</span> <span class="o">=</span> <span class="n">prefix</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">walk</span><span class="p">(</span><span class="n">init_state</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">max_words</span> <span class="o">!=</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">words</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">max_words</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">min_words</span> <span class="o">!=</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">words</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">min_words</span><span class="p">):</span>
            <span class="k">continue</span> <span class="c1"># pragma: no cover # see https://github.com/nedbat/coveragepy/issues/198</span>
        <span class="k">if</span> <span class="n">test_output</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;rejoined_text&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">test_sentence_output</span><span class="p">(</span><span class="n">words</span><span class="p">,</span> <span class="n">mor</span><span class="p">,</span> <span class="n">mot</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">word_join</span><span class="p">(</span><span class="n">words</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">word_join</span><span class="p">(</span><span class="n">words</span><span class="p">)</span>
    <span class="k">return</span> <span class="kc">None</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="markovify.NewlineText.make_sentence_with_start">
    <p>def <span class="ident">make_sentence_with_start</span>(</p><p>self, beginning, strict=True, **kwargs)</p>
    </div>
    
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#markovify.Text">Text</a></code>.<code><a href="#markovify.Text.make_sentence_with_start">make_sentence_with_start</a></code>
    </p>

    
  
    <div class="desc inherited"><p>Tries making a sentence that begins with <code>beginning</code> string,
which should be a string of one to <code>self.state</code> words known
to exist in the corpus.</p>
<p>If strict == True, then markovify will draw its initial inspiration
only from sentences that start with the specified word/phrase.
If strict == False, then markovify will draw its initial inspiration
from any sentence containing the specified word/phrase.
**kwargs are passed to <code>self.make_sentence</code></p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-markovify.NewlineText.make_sentence_with_start', this);">Show source &equiv;</a></p>
  <div id="source-markovify.NewlineText.make_sentence_with_start" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">make_sentence_with_start</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">beginning</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Tries making a sentence that begins with `beginning` string,</span>
<span class="sd">    which should be a string of one to `self.state` words known</span>
<span class="sd">    to exist in the corpus.</span>
<span class="sd">    If strict == True, then markovify will draw its initial inspiration</span>
<span class="sd">    only from sentences that start with the specified word/phrase.</span>
<span class="sd">    If strict == False, then markovify will draw its initial inspiration</span>
<span class="sd">    from any sentence containing the specified word/phrase.</span>
<span class="sd">    **kwargs are passed to `self.make_sentence`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">split</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">word_split</span><span class="p">(</span><span class="n">beginning</span><span class="p">))</span>
    <span class="n">word_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">split</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">word_count</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">state_size</span><span class="p">:</span>
        <span class="n">init_states</span> <span class="o">=</span> <span class="p">[</span> <span class="n">split</span> <span class="p">]</span>
    <span class="k">elif</span> <span class="n">word_count</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">word_count</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">state_size</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">strict</span><span class="p">:</span>
            <span class="n">init_states</span> <span class="o">=</span> <span class="p">[</span> <span class="p">(</span><span class="n">BEGIN</span><span class="p">,)</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state_size</span> <span class="o">-</span> <span class="n">word_count</span><span class="p">)</span> <span class="o">+</span> <span class="n">split</span> <span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">init_states</span> <span class="o">=</span> <span class="p">[</span> <span class="n">key</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
                <span class="c1"># check for starting with begin as well ordered lists</span>
                <span class="k">if</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">!=</span> <span class="n">BEGIN</span><span class="p">,</span> <span class="n">key</span><span class="p">))[:</span><span class="n">word_count</span><span class="p">]</span> <span class="o">==</span> <span class="n">split</span> <span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">secrets</span><span class="o">.</span><span class="n">choice</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])):</span>
              <span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">init_states</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">err_msg</span> <span class="o">=</span> <span class="s2">&quot;`make_sentence_with_start` for this model requires a string containing 1 to </span><span class="si">{0}</span><span class="s2"> words. Yours has </span><span class="si">{1}</span><span class="s2">: </span><span class="si">{2}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state_size</span><span class="p">,</span> <span class="n">word_count</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">split</span><span class="p">))</span>
        <span class="k">raise</span> <span class="n">ParamError</span><span class="p">(</span><span class="n">err_msg</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">init_state</span> <span class="ow">in</span> <span class="n">init_states</span><span class="p">:</span>
        <span class="n">output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_sentence</span><span class="p">(</span><span class="n">init_state</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">output</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">output</span>
    <span class="n">err_msg</span> <span class="o">=</span> <span class="s2">&quot;`make_sentence_with_start` can&#39;t find sentence beginning with </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">beginning</span><span class="p">)</span>
    <span class="k">raise</span> <span class="n">ParamError</span><span class="p">(</span><span class="n">err_msg</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="markovify.NewlineText.make_short_sentence">
    <p>def <span class="ident">make_short_sentence</span>(</p><p>self, max_chars, min_chars=0, **kwargs)</p>
    </div>
    
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#markovify.Text">Text</a></code>.<code><a href="#markovify.Text.make_short_sentence">make_short_sentence</a></code>
    </p>

    
  
    <div class="desc inherited"><p>Tries making a sentence of no more than <code>max_chars</code> characters and optionally
no less than <code>min_chars</code> characters, passing **kwargs to <code>self.make_sentence</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-markovify.NewlineText.make_short_sentence', this);">Show source &equiv;</a></p>
  <div id="source-markovify.NewlineText.make_short_sentence" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">make_short_sentence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_chars</span><span class="p">,</span> <span class="n">min_chars</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Tries making a sentence of no more than `max_chars` characters and optionally</span>
<span class="sd">    no less than `min_chars` characters, passing **kwargs to `self.make_sentence`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">tries</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;tries&#39;</span><span class="p">,</span> <span class="n">DEFAULT_TRIES</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">tries</span><span class="p">):</span>
        <span class="n">sentence</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_sentence</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">sentence</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">sentence</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">max_chars</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">sentence</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">min_chars</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">sentence</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="markovify.NewlineText.sentence_join">
    <p>def <span class="ident">sentence_join</span>(</p><p>self, sentences)</p>
    </div>
    
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#markovify.Text">Text</a></code>.<code><a href="#markovify.Text.sentence_join">sentence_join</a></code>
    </p>

    
  
    <div class="desc inherited"><p>Re-joins a list of sentences into the full text.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-markovify.NewlineText.sentence_join', this);">Show source &equiv;</a></p>
  <div id="source-markovify.NewlineText.sentence_join" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">sentence_join</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sentences</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Re-joins a list of sentences into the full text.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">sentences</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="markovify.NewlineText.sentence_split">
    <p>def <span class="ident">sentence_split</span>(</p><p>self, text)</p>
    </div>
    
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#markovify.Text">Text</a></code>.<code><a href="#markovify.Text.sentence_split">sentence_split</a></code>
    </p>

    
  
    <div class="desc inherited"><p>Splits full-text string into a list of sentences.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-markovify.NewlineText.sentence_split', this);">Show source &equiv;</a></p>
  <div id="source-markovify.NewlineText.sentence_split" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">sentence_split</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\s*\n\s*&quot;</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="markovify.NewlineText.test_sentence_input">
    <p>def <span class="ident">test_sentence_input</span>(</p><p>self, sentence)</p>
    </div>
    
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#markovify.Text">Text</a></code>.<code><a href="#markovify.Text.test_sentence_input">test_sentence_input</a></code>
    </p>

    
  
    <div class="desc inherited"><p>A basic sentence filter. The default rejects sentences that contain
the type of punctuation that would look strange on its own
in a randomly-generated sentence.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-markovify.NewlineText.test_sentence_input', this);">Show source &equiv;</a></p>
  <div id="source-markovify.NewlineText.test_sentence_input" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">test_sentence_input</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sentence</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A basic sentence filter. The default rejects sentences that contain</span>
<span class="sd">    the type of punctuation that would look strange on its own</span>
<span class="sd">    in a randomly-generated sentence.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sentence</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="kc">False</span>
    <span class="c1"># Decode unicode, mainly to normalize fancy quotation marks</span>
    <span class="k">if</span> <span class="n">sentence</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;str&quot;</span><span class="p">:</span> <span class="c1"># pragma: no cover</span>
        <span class="n">decoded</span> <span class="o">=</span> <span class="n">sentence</span>
    <span class="k">else</span><span class="p">:</span> <span class="c1"># pragma: no cover</span>
        <span class="n">decoded</span> <span class="o">=</span> <span class="n">unidecode</span><span class="p">(</span><span class="n">sentence</span><span class="p">)</span>
    <span class="c1"># Sentence shouldn&#39;t contain problematic characters</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">well_formed</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">reject_pat</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">decoded</span><span class="p">):</span> <span class="k">return</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="kc">True</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="markovify.NewlineText.test_sentence_output">
    <p>def <span class="ident">test_sentence_output</span>(</p><p>self, words, max_overlap_ratio, max_overlap_total)</p>
    </div>
    
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#markovify.Text">Text</a></code>.<code><a href="#markovify.Text.test_sentence_output">test_sentence_output</a></code>
    </p>

    
  
    <div class="desc inherited"><p>Given a generated list of words, accept or reject it. This one rejects
sentences that too closely match the original text, namely those that
contain any identical sequence of words of X length, where X is the
smaller number of (a) <code>max_overlap_ratio</code> (default: 0.7) of the total
number of words, and (b) <code>max_overlap_total</code> (default: 15).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-markovify.NewlineText.test_sentence_output', this);">Show source &equiv;</a></p>
  <div id="source-markovify.NewlineText.test_sentence_output" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">test_sentence_output</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">words</span><span class="p">,</span> <span class="n">max_overlap_ratio</span><span class="p">,</span> <span class="n">max_overlap_total</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a generated list of words, accept or reject it. This one rejects</span>
<span class="sd">    sentences that too closely match the original text, namely those that</span>
<span class="sd">    contain any identical sequence of words of X length, where X is the</span>
<span class="sd">    smaller number of (a) `max_overlap_ratio` (default: 0.7) of the total</span>
<span class="sd">    number of words, and (b) `max_overlap_total` (default: 15).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Reject large chunks of similarity</span>
    <span class="n">overlap_ratio</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">max_overlap_ratio</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">words</span><span class="p">)))</span>
    <span class="n">overlap_max</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">max_overlap_total</span><span class="p">,</span> <span class="n">overlap_ratio</span><span class="p">)</span>
    <span class="n">overlap_over</span> <span class="o">=</span> <span class="n">overlap_max</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">gram_count</span> <span class="o">=</span> <span class="nb">max</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">words</span><span class="p">)</span> <span class="o">-</span> <span class="n">overlap_max</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">grams</span> <span class="o">=</span> <span class="p">[</span> <span class="n">words</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="n">overlap_over</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">gram_count</span><span class="p">)</span> <span class="p">]</span>
    <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">grams</span><span class="p">:</span>
        <span class="n">gram_joined</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">word_join</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">gram_joined</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">rejoined_text</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="kc">True</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="markovify.NewlineText.to_dict">
    <p>def <span class="ident">to_dict</span>(</p><p>self)</p>
    </div>
    
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#markovify.Text">Text</a></code>.<code><a href="#markovify.Text.to_dict">to_dict</a></code>
    </p>

    
  
    <div class="desc inherited"><p>Returns the underlying data as a Python dict.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-markovify.NewlineText.to_dict', this);">Show source &equiv;</a></p>
  <div id="source-markovify.NewlineText.to_dict" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">to_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the underlying data as a Python dict.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">{</span>
        <span class="s2">&quot;state_size&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">state_size</span><span class="p">,</span>
        <span class="s2">&quot;chain&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">to_json</span><span class="p">(),</span>
        <span class="s2">&quot;parsed_sentences&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">parsed_sentences</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">retain_original</span> <span class="k">else</span> <span class="kc">None</span>
    <span class="p">}</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="markovify.NewlineText.to_json">
    <p>def <span class="ident">to_json</span>(</p><p>self)</p>
    </div>
    
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#markovify.Text">Text</a></code>.<code><a href="#markovify.Text.to_json">to_json</a></code>
    </p>

    
  
    <div class="desc inherited"><p>Returns the underlying data as a JSON string.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-markovify.NewlineText.to_json', this);">Show source &equiv;</a></p>
  <div id="source-markovify.NewlineText.to_json" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">to_json</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the underlying data as a JSON string.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">to_dict</span><span class="p">())</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="markovify.NewlineText.word_join">
    <p>def <span class="ident">word_join</span>(</p><p>self, words)</p>
    </div>
    
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#markovify.Text">Text</a></code>.<code><a href="#markovify.Text.word_join">word_join</a></code>
    </p>

    
  
    <div class="desc inherited"><p>Re-joins a list of words into a sentence.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-markovify.NewlineText.word_join', this);">Show source &equiv;</a></p>
  <div id="source-markovify.NewlineText.word_join" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">word_join</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">words</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Re-joins a list of words into a sentence.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">words</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="markovify.NewlineText.word_split">
    <p>def <span class="ident">word_split</span>(</p><p>self, sentence)</p>
    </div>
    
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#markovify.Text">Text</a></code>.<code><a href="#markovify.Text.word_split">word_split</a></code>
    </p>

    
  
    <div class="desc inherited"><p>Splits a sentence into a list of words.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-markovify.NewlineText.word_split', this);">Show source &equiv;</a></p>
  <div id="source-markovify.NewlineText.word_split" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">word_split</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sentence</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Splits a sentence into a list of words.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">word_split_pattern</span><span class="p">,</span> <span class="n">sentence</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
      </div>
      </div>
      
      <div class="item">
      <p id="markovify.ParamError" class="name">class <span class="ident">ParamError</span></p>
      
  
    <div class="desc"><p>Common base class for all non-exit exceptions.</p></div>
  <div class="source_cont">
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="/builtins.Exception.ext">builtins.Exception</a></li>
          <li><a href="/builtins.BaseException.ext">builtins.BaseException</a></li>
          </ul>
          <h3>Class variables</h3>
            <div class="item">
            <p id="markovify.ParamError.args" class="name">var <span class="ident">args</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Methods</h3>
            
  <div class="item">
    <div class="name def" id="markovify.ParamError.with_traceback">
    <p>def <span class="ident">with_traceback</span>(</p><p>...)</p>
    </div>
    

    
  
    <div class="desc"><p>Exception.with_traceback(tb) &ndash;
set self.<strong>traceback</strong> to tb and return self.</p></div>
  <div class="source_cont">
</div>

  </div>
  
      </div>
      </div>
      
      <div class="item">
      <p id="markovify.Text" class="name">class <span class="ident">Text</span></p>
      
  
  <div class="source_cont">
</div>


      <div class="class">
          <h3>Class variables</h3>
            <div class="item">
            <p id="markovify.Text.reject_pat" class="name">var <span class="ident">reject_pat</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="markovify.Text.word_split_pattern" class="name">var <span class="ident">word_split_pattern</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="markovify.Text.from_chain">
    <p>def <span class="ident">from_chain</span>(</p><p>chain_json, corpus=None, parsed_sentences=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Init a Text class based on an existing chain JSON string or object
If corpus is None, overlap checking won't work.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-markovify.Text.from_chain', this);">Show source &equiv;</a></p>
  <div id="source-markovify.Text.from_chain" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@classmethod</span>
<span class="k">def</span> <span class="nf">from_chain</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">chain_json</span><span class="p">,</span> <span class="n">corpus</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">parsed_sentences</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Init a Text class based on an existing chain JSON string or object</span>
<span class="sd">    If corpus is None, overlap checking won&#39;t work.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">chain</span> <span class="o">=</span> <span class="n">Chain</span><span class="o">.</span><span class="n">from_json</span><span class="p">(</span><span class="n">chain_json</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">corpus</span> <span class="ow">or</span> <span class="kc">None</span><span class="p">,</span> <span class="n">parsed_sentences</span><span class="o">=</span><span class="n">parsed_sentences</span><span class="p">,</span> <span class="n">state_size</span><span class="o">=</span><span class="n">chain</span><span class="o">.</span><span class="n">state_size</span><span class="p">,</span> <span class="n">chain</span><span class="o">=</span><span class="n">chain</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="markovify.Text.from_dict">
    <p>def <span class="ident">from_dict</span>(</p><p>obj, **kwargs)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-markovify.Text.from_dict', this);">Show source &equiv;</a></p>
  <div id="source-markovify.Text.from_dict" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@classmethod</span>
<span class="k">def</span> <span class="nf">from_dict</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span>
        <span class="kc">None</span><span class="p">,</span>
        <span class="n">state_size</span><span class="o">=</span><span class="n">obj</span><span class="p">[</span><span class="s2">&quot;state_size&quot;</span><span class="p">],</span>
        <span class="n">chain</span><span class="o">=</span><span class="n">Chain</span><span class="o">.</span><span class="n">from_json</span><span class="p">(</span><span class="n">obj</span><span class="p">[</span><span class="s2">&quot;chain&quot;</span><span class="p">]),</span>
        <span class="n">parsed_sentences</span><span class="o">=</span><span class="n">obj</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;parsed_sentences&quot;</span><span class="p">)</span>
    <span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="markovify.Text.from_json">
    <p>def <span class="ident">from_json</span>(</p><p>json_str)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-markovify.Text.from_json', this);">Show source &equiv;</a></p>
  <div id="source-markovify.Text.from_json" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@classmethod</span>
<span class="k">def</span> <span class="nf">from_json</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">json_str</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">json_str</span><span class="p">))</span>
</pre></div>

  </div>
</div>

  </div>
  
          <h3>Methods</h3>
            
  <div class="item">
    <div class="name def" id="markovify.Text.compile">
    <p>def <span class="ident">compile</span>(</p><p>self, inplace=False)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-markovify.Text.compile', this);">Show source &equiv;</a></p>
  <div id="source-markovify.Text.compile" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">compile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inplace</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">inplace</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>
    <span class="n">cchain</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">inplace</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
    <span class="n">psent</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;parsed_sentences&#39;</span><span class="p">):</span>
        <span class="n">psent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parsed_sentences</span>
    <span class="k">return</span> <span class="n">Text</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> \
                <span class="n">state_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">state_size</span><span class="p">,</span> \
                <span class="n">chain</span> <span class="o">=</span> <span class="n">cchain</span><span class="p">,</span> \
                <span class="n">parsed_sentences</span> <span class="o">=</span> <span class="n">psent</span><span class="p">,</span> \
                <span class="n">retain_original</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">retain_original</span><span class="p">,</span> \
                <span class="n">well_formed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">well_formed</span><span class="p">,</span> \
                <span class="n">reject_reg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reject_pat</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="markovify.Text.generate_corpus">
    <p>def <span class="ident">generate_corpus</span>(</p><p>self, text)</p>
    </div>
    

    
  
    <div class="desc"><p>Given a text string, returns a list of lists; that is, a list of
"sentences," each of which is a list of words. Before splitting into
words, the sentences are filtered through <code>self.test_sentence_input</code></p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-markovify.Text.generate_corpus', this);">Show source &equiv;</a></p>
  <div id="source-markovify.Text.generate_corpus" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">generate_corpus</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a text string, returns a list of lists; that is, a list of</span>
<span class="sd">    &quot;sentences,&quot; each of which is a list of words. Before splitting into</span>
<span class="sd">    words, the sentences are filtered through `self.test_sentence_input`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">sentences</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sentence_split</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">sentences</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">text</span><span class="p">:</span>
            <span class="n">sentences</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sentence_split</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
    <span class="n">passing</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">test_sentence_input</span><span class="p">,</span> <span class="n">sentences</span><span class="p">)</span>
    <span class="n">runs</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">word_split</span><span class="p">,</span> <span class="n">passing</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">runs</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="markovify.Text.make_sentence">
    <p>def <span class="ident">make_sentence</span>(</p><p>self, init_state=None, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Attempts <code>tries</code> (default: 10) times to generate a valid sentence,
based on the model and <code>test_sentence_output</code>. Passes <code>max_overlap_ratio</code>
and <code>max_overlap_total</code> to <code>test_sentence_output</code>.
If successful, returns the sentence as a string. If not, returns None.
If <code>init_state</code> (a tuple of <code>self.chain.state_size</code> words) is not specified,
this method chooses a sentence-start at random, in accordance with
the model.
If <code>test_output</code> is set as False then the <code>test_sentence_output</code> check
will be skipped.
If <code>max_words</code> or <code>min_words</code> are specified, the word count for the sentence will be
evaluated against the provided limit(s).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-markovify.Text.make_sentence', this);">Show source &equiv;</a></p>
  <div id="source-markovify.Text.make_sentence" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">make_sentence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">init_state</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Attempts `tries` (default: 10) times to generate a valid sentence,</span>
<span class="sd">    based on the model and `test_sentence_output`. Passes `max_overlap_ratio`</span>
<span class="sd">    and `max_overlap_total` to `test_sentence_output`.</span>
<span class="sd">    If successful, returns the sentence as a string. If not, returns None.</span>
<span class="sd">    If `init_state` (a tuple of `self.chain.state_size` words) is not specified,</span>
<span class="sd">    this method chooses a sentence-start at random, in accordance with</span>
<span class="sd">    the model.</span>
<span class="sd">    If `test_output` is set as False then the `test_sentence_output` check</span>
<span class="sd">    will be skipped.</span>
<span class="sd">    If `max_words` or `min_words` are specified, the word count for the sentence will be</span>
<span class="sd">    evaluated against the provided limit(s).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">tries</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;tries&#39;</span><span class="p">,</span> <span class="n">DEFAULT_TRIES</span><span class="p">)</span>
    <span class="n">mor</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;max_overlap_ratio&#39;</span><span class="p">,</span> <span class="n">DEFAULT_MAX_OVERLAP_RATIO</span><span class="p">)</span>
    <span class="n">mot</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;max_overlap_total&#39;</span><span class="p">,</span> <span class="n">DEFAULT_MAX_OVERLAP_TOTAL</span><span class="p">)</span>
    <span class="n">test_output</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;test_output&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
    <span class="n">max_words</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;max_words&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">min_words</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;min_words&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">init_state</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">prefix</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">init_state</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">prefix</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">word</span> <span class="o">==</span> <span class="n">BEGIN</span><span class="p">:</span>
                <span class="n">prefix</span> <span class="o">=</span> <span class="n">prefix</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">break</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">prefix</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">tries</span><span class="p">):</span>
        <span class="n">words</span> <span class="o">=</span> <span class="n">prefix</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">walk</span><span class="p">(</span><span class="n">init_state</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">max_words</span> <span class="o">!=</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">words</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">max_words</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">min_words</span> <span class="o">!=</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">words</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">min_words</span><span class="p">):</span>
            <span class="k">continue</span> <span class="c1"># pragma: no cover # see https://github.com/nedbat/coveragepy/issues/198</span>
        <span class="k">if</span> <span class="n">test_output</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;rejoined_text&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">test_sentence_output</span><span class="p">(</span><span class="n">words</span><span class="p">,</span> <span class="n">mor</span><span class="p">,</span> <span class="n">mot</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">word_join</span><span class="p">(</span><span class="n">words</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">word_join</span><span class="p">(</span><span class="n">words</span><span class="p">)</span>
    <span class="k">return</span> <span class="kc">None</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="markovify.Text.make_sentence_with_start">
    <p>def <span class="ident">make_sentence_with_start</span>(</p><p>self, beginning, strict=True, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Tries making a sentence that begins with <code>beginning</code> string,
which should be a string of one to <code>self.state</code> words known
to exist in the corpus.</p>
<p>If strict == True, then markovify will draw its initial inspiration
only from sentences that start with the specified word/phrase.
If strict == False, then markovify will draw its initial inspiration
from any sentence containing the specified word/phrase.
**kwargs are passed to <code>self.make_sentence</code></p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-markovify.Text.make_sentence_with_start', this);">Show source &equiv;</a></p>
  <div id="source-markovify.Text.make_sentence_with_start" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">make_sentence_with_start</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">beginning</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Tries making a sentence that begins with `beginning` string,</span>
<span class="sd">    which should be a string of one to `self.state` words known</span>
<span class="sd">    to exist in the corpus.</span>
<span class="sd">    If strict == True, then markovify will draw its initial inspiration</span>
<span class="sd">    only from sentences that start with the specified word/phrase.</span>
<span class="sd">    If strict == False, then markovify will draw its initial inspiration</span>
<span class="sd">    from any sentence containing the specified word/phrase.</span>
<span class="sd">    **kwargs are passed to `self.make_sentence`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">split</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">word_split</span><span class="p">(</span><span class="n">beginning</span><span class="p">))</span>
    <span class="n">word_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">split</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">word_count</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">state_size</span><span class="p">:</span>
        <span class="n">init_states</span> <span class="o">=</span> <span class="p">[</span> <span class="n">split</span> <span class="p">]</span>
    <span class="k">elif</span> <span class="n">word_count</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">word_count</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">state_size</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">strict</span><span class="p">:</span>
            <span class="n">init_states</span> <span class="o">=</span> <span class="p">[</span> <span class="p">(</span><span class="n">BEGIN</span><span class="p">,)</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state_size</span> <span class="o">-</span> <span class="n">word_count</span><span class="p">)</span> <span class="o">+</span> <span class="n">split</span> <span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">init_states</span> <span class="o">=</span> <span class="p">[</span> <span class="n">key</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
                <span class="c1"># check for starting with begin as well ordered lists</span>
                <span class="k">if</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">!=</span> <span class="n">BEGIN</span><span class="p">,</span> <span class="n">key</span><span class="p">))[:</span><span class="n">word_count</span><span class="p">]</span> <span class="o">==</span> <span class="n">split</span> <span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">secrets</span><span class="o">.</span><span class="n">choice</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])):</span>
              <span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">init_states</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">err_msg</span> <span class="o">=</span> <span class="s2">&quot;`make_sentence_with_start` for this model requires a string containing 1 to </span><span class="si">{0}</span><span class="s2"> words. Yours has </span><span class="si">{1}</span><span class="s2">: </span><span class="si">{2}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state_size</span><span class="p">,</span> <span class="n">word_count</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">split</span><span class="p">))</span>
        <span class="k">raise</span> <span class="n">ParamError</span><span class="p">(</span><span class="n">err_msg</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">init_state</span> <span class="ow">in</span> <span class="n">init_states</span><span class="p">:</span>
        <span class="n">output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_sentence</span><span class="p">(</span><span class="n">init_state</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">output</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">output</span>
    <span class="n">err_msg</span> <span class="o">=</span> <span class="s2">&quot;`make_sentence_with_start` can&#39;t find sentence beginning with </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">beginning</span><span class="p">)</span>
    <span class="k">raise</span> <span class="n">ParamError</span><span class="p">(</span><span class="n">err_msg</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="markovify.Text.make_short_sentence">
    <p>def <span class="ident">make_short_sentence</span>(</p><p>self, max_chars, min_chars=0, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Tries making a sentence of no more than <code>max_chars</code> characters and optionally
no less than <code>min_chars</code> characters, passing **kwargs to <code>self.make_sentence</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-markovify.Text.make_short_sentence', this);">Show source &equiv;</a></p>
  <div id="source-markovify.Text.make_short_sentence" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">make_short_sentence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_chars</span><span class="p">,</span> <span class="n">min_chars</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Tries making a sentence of no more than `max_chars` characters and optionally</span>
<span class="sd">    no less than `min_chars` characters, passing **kwargs to `self.make_sentence`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">tries</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;tries&#39;</span><span class="p">,</span> <span class="n">DEFAULT_TRIES</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">tries</span><span class="p">):</span>
        <span class="n">sentence</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_sentence</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">sentence</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">sentence</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">max_chars</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">sentence</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">min_chars</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">sentence</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="markovify.Text.sentence_join">
    <p>def <span class="ident">sentence_join</span>(</p><p>self, sentences)</p>
    </div>
    

    
  
    <div class="desc"><p>Re-joins a list of sentences into the full text.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-markovify.Text.sentence_join', this);">Show source &equiv;</a></p>
  <div id="source-markovify.Text.sentence_join" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">sentence_join</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sentences</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Re-joins a list of sentences into the full text.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">sentences</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="markovify.Text.sentence_split">
    <p>def <span class="ident">sentence_split</span>(</p><p>self, text)</p>
    </div>
    

    
  
    <div class="desc"><p>Splits full-text string into a list of sentences.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-markovify.Text.sentence_split', this);">Show source &equiv;</a></p>
  <div id="source-markovify.Text.sentence_split" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">sentence_split</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Splits full-text string into a list of sentences.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">split_into_sentences</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="markovify.Text.test_sentence_input">
    <p>def <span class="ident">test_sentence_input</span>(</p><p>self, sentence)</p>
    </div>
    

    
  
    <div class="desc"><p>A basic sentence filter. The default rejects sentences that contain
the type of punctuation that would look strange on its own
in a randomly-generated sentence.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-markovify.Text.test_sentence_input', this);">Show source &equiv;</a></p>
  <div id="source-markovify.Text.test_sentence_input" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">test_sentence_input</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sentence</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A basic sentence filter. The default rejects sentences that contain</span>
<span class="sd">    the type of punctuation that would look strange on its own</span>
<span class="sd">    in a randomly-generated sentence.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sentence</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="kc">False</span>
    <span class="c1"># Decode unicode, mainly to normalize fancy quotation marks</span>
    <span class="k">if</span> <span class="n">sentence</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;str&quot;</span><span class="p">:</span> <span class="c1"># pragma: no cover</span>
        <span class="n">decoded</span> <span class="o">=</span> <span class="n">sentence</span>
    <span class="k">else</span><span class="p">:</span> <span class="c1"># pragma: no cover</span>
        <span class="n">decoded</span> <span class="o">=</span> <span class="n">unidecode</span><span class="p">(</span><span class="n">sentence</span><span class="p">)</span>
    <span class="c1"># Sentence shouldn&#39;t contain problematic characters</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">well_formed</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">reject_pat</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">decoded</span><span class="p">):</span> <span class="k">return</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="kc">True</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="markovify.Text.test_sentence_output">
    <p>def <span class="ident">test_sentence_output</span>(</p><p>self, words, max_overlap_ratio, max_overlap_total)</p>
    </div>
    

    
  
    <div class="desc"><p>Given a generated list of words, accept or reject it. This one rejects
sentences that too closely match the original text, namely those that
contain any identical sequence of words of X length, where X is the
smaller number of (a) <code>max_overlap_ratio</code> (default: 0.7) of the total
number of words, and (b) <code>max_overlap_total</code> (default: 15).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-markovify.Text.test_sentence_output', this);">Show source &equiv;</a></p>
  <div id="source-markovify.Text.test_sentence_output" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">test_sentence_output</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">words</span><span class="p">,</span> <span class="n">max_overlap_ratio</span><span class="p">,</span> <span class="n">max_overlap_total</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a generated list of words, accept or reject it. This one rejects</span>
<span class="sd">    sentences that too closely match the original text, namely those that</span>
<span class="sd">    contain any identical sequence of words of X length, where X is the</span>
<span class="sd">    smaller number of (a) `max_overlap_ratio` (default: 0.7) of the total</span>
<span class="sd">    number of words, and (b) `max_overlap_total` (default: 15).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Reject large chunks of similarity</span>
    <span class="n">overlap_ratio</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">max_overlap_ratio</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">words</span><span class="p">)))</span>
    <span class="n">overlap_max</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">max_overlap_total</span><span class="p">,</span> <span class="n">overlap_ratio</span><span class="p">)</span>
    <span class="n">overlap_over</span> <span class="o">=</span> <span class="n">overlap_max</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">gram_count</span> <span class="o">=</span> <span class="nb">max</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">words</span><span class="p">)</span> <span class="o">-</span> <span class="n">overlap_max</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">grams</span> <span class="o">=</span> <span class="p">[</span> <span class="n">words</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="n">overlap_over</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">gram_count</span><span class="p">)</span> <span class="p">]</span>
    <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">grams</span><span class="p">:</span>
        <span class="n">gram_joined</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">word_join</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">gram_joined</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">rejoined_text</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="kc">True</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="markovify.Text.to_dict">
    <p>def <span class="ident">to_dict</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns the underlying data as a Python dict.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-markovify.Text.to_dict', this);">Show source &equiv;</a></p>
  <div id="source-markovify.Text.to_dict" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">to_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the underlying data as a Python dict.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">{</span>
        <span class="s2">&quot;state_size&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">state_size</span><span class="p">,</span>
        <span class="s2">&quot;chain&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">to_json</span><span class="p">(),</span>
        <span class="s2">&quot;parsed_sentences&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">parsed_sentences</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">retain_original</span> <span class="k">else</span> <span class="kc">None</span>
    <span class="p">}</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="markovify.Text.to_json">
    <p>def <span class="ident">to_json</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns the underlying data as a JSON string.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-markovify.Text.to_json', this);">Show source &equiv;</a></p>
  <div id="source-markovify.Text.to_json" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">to_json</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the underlying data as a JSON string.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">to_dict</span><span class="p">())</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="markovify.Text.word_join">
    <p>def <span class="ident">word_join</span>(</p><p>self, words)</p>
    </div>
    

    
  
    <div class="desc"><p>Re-joins a list of words into a sentence.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-markovify.Text.word_join', this);">Show source &equiv;</a></p>
  <div id="source-markovify.Text.word_join" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">word_join</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">words</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Re-joins a list of words into a sentence.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">words</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="markovify.Text.word_split">
    <p>def <span class="ident">word_split</span>(</p><p>self, sentence)</p>
    </div>
    

    
  
    <div class="desc"><p>Splits a sentence into a list of words.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-markovify.Text.word_split', this);">Show source &equiv;</a></p>
  <div id="source-markovify.Text.word_split" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">word_split</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sentence</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Splits a sentence into a list of words.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">word_split_pattern</span><span class="p">,</span> <span class="n">sentence</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
      </div>
      </div>

  </section>
</article>
  <div class="clear"> </div>
  <footer id="footer">
    <p>
      Generated by <a href="https://github.com/timothycrosley/pdocs">pdocs 1.1.1</a>
    </p>
  </footer>
</div>
</body>
</html>